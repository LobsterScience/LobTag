


simulate.movement = function(movement.rate = NULL, canvas = NULL, release.pos = NULL, ndays = 365*4, bestof = 4, ncrab = 100 ,type = "least.cost"){
  if(is.null(canvas)) canvas = file.path("C:", "workspace","data", "maps", "depthraster2.tif")
  if(is.null(movement.rate)) movement.rate = ave(max.rate.tag(n = 10))
  if(is.null(release.pos)) release.pos = c(-59.9, 46.5)   
  raster.path = canvas
  r <- raster(raster.path)
  mr = as.matrix(r)
  mr[which(mr>-280 & mr< -60)] = -170
  mr = apply(mr, 2, function(x) dnorm(x,mean=-170,sd=60))
  r = setValues(r, mr)
  
  tr <- transition(r, mean, directions=16)
  if(type  == "random.walk"){
    trans <- geoCorrection(tr, type = "r", scl=FALSE)
  }
  if(type  == "least.cost"){
    trans <- geoCorrection(tr, type = "c", scl=FALSE)
  }
  crab = data.frame(1:100)
  crab$path = ""
  crab$curlon = release.pos[1]
  crab$curlat = release.pos[2]
  for(i in 1:ndays){
    
    for(c in 1:nrow(crab)){
      
      cost = 100000000000
      dir = sample(1:360, bestof, replace=TRUE)
      temppos = NULL
      for(b in 1:bestof){
        
        dp = destPoint(c(crab$curlon[c], crab$curlat[c]), dir[b], movement.rate)
        cd = costDistance(tr, c(crab$curlon[c], crab$curlat[c]), dp)
        
        if(cd < cost){
          temppos = dp
          cost = cd
        }
      }
      crab$path[c] = paste(crab$path[c], temppos[1], ",",temppos[2], sep ="")
      crab$curlon[c] = temppos[1]
      crab$curlat[c] = temppos[2]
      
    }
  }
  
  
}
max.rate.tag = function(n = 1){
  data = get.capturedata()
  ind = which(data$area == 'GULF')
  if(length(ind)>0) data = data[-ind,]
  
  ind = which(data$caplat == '0')
  if(length(ind)>0) data = data[-ind,]
  
  
  dist = distHaversine(cbind(as.numeric(data$rellon), as.numeric(data$rellat)), cbind(as.numeric(data$caplon) ,as.numeric(data$caplat)), r=6378137)
  inter = interval(data$sampdat, data$capdate)
  days = time_length(as.duration(inter), "days")
  
  
  
  
  #Remove days less than 1 year, account for drift
  data$dist = dist
  data$days = days
  ind = which(data$days <= 365 )
  if(length(ind)>0) data = data[-ind,]
  ind = which(is.na(data$days))
  if(length(ind)>0) data = data[-ind,]
  
  
  data$m.per.day = data$dist/data$days
  data = data[order(data$m.per.day, decreasing = T),]
  
  #remove gulf program data  
  ind = which(grepl("G", data$PID))
  if(length(ind)>0) data = data[-ind,]
  
  data$m.per.day
  return(data$m.per.day[1:n])
}
statsfigures = function(){
  require(lubridate)
  require(easyGgplot2)
  out = data.frame()
  outall = data.frame()
  outarea = data.frame()
  years = 2004:2020
  nens = NULL
  sens = NULL
  xxxx = NULL
  for(i in 1:length(years)){
    print(years[i])
    zn = tagReturned_Applied("nens", as.character(years[i]))
    zta = tagApplied("nens", as.character(years[i]))
    zpn = tagReturned_Year("nens", as.character(years[i]))
    zs = tagReturned_Applied("sens", as.character(years[i]))
    zsa = tagApplied("sens", as.character(years[i]))
    zps = tagReturned_Year("sens", as.character(years[i]))
    zf = tagReturned_Applied("cfa4x", as.character(years[i]))
    zfa = tagApplied("cfa4x", as.character(years[i]))
    zpx = tagReturned_Year("cfa4x", as.character(years[i]))
    za = tagReturned_Applied("all", as.character(years[i]))
    zaa = tagApplied("all", as.character(years[i]))
    zpa = tagReturned_Year("all", as.character(years[i]))
    if(!is.numeric(zsa))zsa = 0
    if(!is.numeric(zta))zta = 0
    if(!is.numeric(zfa))zfa = 0
    if(!is.numeric(zaa))zaa = 0
    if(zpn == FALSE){
      zpn = NULL
      zpn$a = 0
      zpn$b = 0
    }
    if(zpx == FALSE){
      zpx = NULL
      zpx$a = 0
      zpx$b = 0
    }
    if(!is.logical(zn)){
      nens = c(nens, zn$retuni/zta)
      zn$year = as.character(years[i])
      zn$area = "nens"
      zn$tapp = zta
      zn$peo = zpn$a
      zn$upeo = zpn$b
      out = rbind(out, data.frame(zn))
    }else{
      nens = c(nens, NA)
    }
    if(!is.logical(zs)){
      sens = c(sens, zs$retuni/zsa)
      zs$year = as.character(years[i])
      zs$area = "sens"
      zs$tapp = zsa
      zs$peo = zps$a
      zs$upeo = zps$b
      out = rbind(out, data.frame(zs))
      
      
    }else{
      sens = c(sens, NA)
    }
    if(!is.logical(zf)){  
      xxxx = c(xxxx, zf$retuni/zfa)
      zf$year = as.character(years[i])
      zf$area = "cfa4x"
      zf$tapp = zfa
      zf$peo = zpx$a
      zf$upeo = zpx$b
      out = rbind(out, data.frame(zf))
      
    }else{
      xxxx = c(xxxx, NA)
    }
    if(!is.logical(za)){  
      za$year = as.character(years[i])
      za$area = "all"
      za$tapp = zaa
      za$peo = zpa$a
      za$upeo = zpa$b
      outall = rbind(outall, data.frame(za))
      
    }
    #     if(!is.logical(zn) && !zta == 0)
    #      nens = c(nens, zn$retuni)
    #     else nens = c(nens, NA)
    #     
    #     if(!is.logical(zs))
    #      sens = c(sens, zs$retuni)
    #     else sens = c(sens, NA)
    #     
    #     if(!is.logical(zf))  
    #      xxxx = c(xxxx, zf$retuni)
    #     else xxxx = c(xxxx, NA)
  }
  years = "2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020"
  za = tagReturned_Applied("all", as.character(years))
  zaa = tagApplied("all", as.character(years))
  zpa = tagReturned_Year("all", as.character(years))
  if(!is.logical(za)){  
    za$year = as.character(years[i])
    za$area = "all"
    za$tapp = zaa
    za$peo = zpa$a
    za$upeo = zpa$b
    outall = rbind(outall, data.frame(za))
    
  }
  write.csv( out, file.path("C:", "SCtagging", "output", "stats_year_area.csv"))
  write.csv( outall, file.path("C:", "SCtagging", "output", "stats_year.csv"))
  
  
  #####################################################
  
  
  regions = c("cfanorth", "cfasouth", "cfa4x")
  k <- data.frame(nens, sens, xxxx)
  k = as.data.frame( k )
  colnames(k) = regions
  rownames(k) = unlist(strsplit(years, ","))
  k = k[3:nrow(k),]
  uyrs = as.numeric(rownames(k) ) 
  pts = c(19, 22, 24)
  lns = c(1, 1, 1)
  cols = c("goldenrod2", "coral3",  "mediumpurple2")
  yrange = range (k, na.rm=T)
  yrange[1] = 0
  xrange = range(uyrs)
  xrange[1] = xrange[1]
  xrange[2] = xrange[2]
  
  fn = file.path("C:", "SCtagging", "output","returns.pdf" )
  pdf(file=fn, width=7, height=7, bg='white')
  m=1
  miss <- !is.na(k[,m])
  plot( uyrs[miss], na.omit(k[,m]),  type="b", col=cols[m], lwd=3, lty=lns[m], pch=pts[m], xlim=xrange, ylim=yrange, ylab="Return Rate(applied/returned)", xlab="Year")
  
  m=2
  miss <- !is.na(k[,m])
  lines( uyrs[miss], na.omit(k[,m]), type="b", col=cols[m], lwd=3, lty=lns[m], pch=pts[m], xlim=xrange, ylim=yrange)
  
  m=3
  miss <- !is.na(k[,m])
  lines( uyrs[miss], na.omit(k[,m]), type="b", col=cols[m], lwd=3, lty=lns[m], pch=pts[m], xlim=xrange, ylim=yrange)
  
  legend("topright", c("N-ENS", "S-ENS", "4X"), bty="n", lty=lns, lwd=2, pch=pts, col=cols, cex=1.2 )
  
  dev.off()
  
  
  
  k <- data.frame(out$upeo[which(out$area == "nens")], out$upeo[which(out$area == "sens")], out$upeo[which(out$area == "cfa4x")])
  k = as.data.frame( k )
  colnames(k) = regions
  rownames(k) =   unlist(strsplit(years, ","))
  k = k[3:nrow(k),]
  uyrs = as.numeric(rownames(k) ) 
  pts = c(19, 22, 24)
  lns = c(1, 1, 1)
  cols = c("goldenrod2", "coral3",  "mediumpurple2")
  yrange = range (k, na.rm=T)
  yrange[1] = 0
  xrange = range(uyrs)
  xrange[1] = xrange[1]
  xrange[2] = xrange[2]
  xlabels = seq(xrange[1]+1, xrange[2], 2)
  fn = file.path("C:", "SCtagging", "output","people.pdf" )
  pdf(file=fn, width=7, height=7, bg='white')
  m=1
  miss <- !is.na(k[,m])
  plot( uyrs[miss], na.omit(k[,m]),  type="b", col=cols[m], lwd=3, lty=lns[m], pch=pts[m], xlim=xrange, ylim=yrange, ylab="Number of People", xlab="Year")
  
  m=2
  miss <- !is.na(k[,m])
  lines( uyrs[miss], na.omit(k[,m]), type="b", col=cols[m], lwd=3, lty=lns[m], pch=pts[m], xlim=xrange, ylim=yrange)
  
  m=3
  miss <- !is.na(k[,m])
  lines( uyrs[miss], na.omit(k[,m]), type="b", col=cols[m], lwd=3, lty=lns[m], pch=pts[m], xlim=xrange, ylim=yrange)
  
  legend("topleft", c("N-ENS", "S-ENS", "4X"), bty="n", lty=lns, lwd=2, pch=pts, col=cols, cex=1.2 )
  
  dev.off()
  
  
  
  
  
  
  
  
  
  
  k <- data.frame(out$spe[which(out$area == "nens")], out$spe[which(out$area == "sens")], out$spe[which(out$area == "cfa4x")])
  k = as.data.frame( k )
  colnames(k) = regions
  rownames(k) =   unlist(strsplit(years, ","))
  k = k[3:nrow(k),]
  uyrs = as.numeric(rownames(k) ) 
  pts = c(19, 22, 24)
  lns = c(1, 1, 1)
  cols = c("goldenrod2", "coral3",  "mediumpurple2")
  yrange = range (k, na.rm=T)
  yrange[1] = 0
  xrange = range(uyrs)
  xrange[1] = xrange[1]
  xrange[2] = xrange[2]
  xlabels = seq(xrange[1]+1, xrange[2], 2)
  fn = file.path("C:", "SCtagging", "output","movrate.pdf" )
  pdf(file=fn, width=7, height=7, bg='white')
  m=1
  miss <- !is.na(k[,m])
  plot( uyrs[miss], na.omit(k[,m]),  type="b", col=cols[m], lwd=3, lty=lns[m], pch=pts[m], xlim=xrange, ylim=yrange, ylab="Movement Rate (km/month)", xlab="Year")
  
  m=2
  miss <- !is.na(k[,m])
  lines( uyrs[miss], na.omit(k[,m]), type="b", col=cols[m], lwd=3, lty=lns[m], pch=pts[m], xlim=xrange, ylim=yrange)
  
  m=3
  miss <- !is.na(k[,m])
  lines( uyrs[miss], na.omit(k[,m]), type="b", col=cols[m], lwd=3, lty=lns[m], pch=pts[m], xlim=xrange, ylim=yrange)
  
  legend("topleft", c("N-ENS", "S-ENS", "4X"), bty="n", lty=lns, lwd=2, pch=pts, col=cols, cex=1.2 )
  
  dev.off()
  ########################################################
  
  outarea = NULL
  
  zn = tagReturned_Applied("nens", as.character(years))
  zta = tagApplied("nens", as.character(years))
  zs = tagReturned_Applied("sens", as.character(years))
  zsa = tagApplied("sens", as.character(years))
  zf = tagReturned_Applied("cfa4x", as.character(years))
  zfa = tagApplied("cfa4x", as.character(years))
  za = tagReturned_Applied("all", as.character(years))
  zaa = tagApplied("all", as.character(years))
  zpx = tagReturned_Year("cfa4x", as.character(years))
  zpn = tagReturned_Year("nens", as.character(years))
  zps = tagReturned_Year("sens", as.character(years))
  zn$year = "all"
  zn$area = "nens"
  zn$tapp = zta
  zn$peo = zpn$a
  zn$upeo = zpn$b
  outarea = rbind(outarea, data.frame(zn))
  zs$year = "all"
  zs$area = "sens"
  zs$tapp = zsa
  zs$peo = zps$a
  zs$upeo = zps$b
  outarea = rbind(outarea, data.frame(zs))
  zf$year = "all"
  zf$area = "cfa4x"
  zf$tapp = zfa
  zf$peo = zpx$a
  zf$upeo = zpx$b
  outarea = rbind(outarea, data.frame(zf))       
  zna = tagReturned_Applied("all", as.character(years))
  ztaa = tagApplied("all", as.character(years))
  zpaa = tagReturned_Year("all", as.character(years))
  
  zna$year = "all"
  zna$area = "all"
  zna$tapp = ztaa
  zna$peo = zpaa$a
  zna$upeo = zpaa$b
  outarea = rbind(outarea, data.frame(zna))   
  
  write.csv( outarea, file.path("C:", "SCtagging", "output", "stats_area.csv"))
  
  
  ######################################################################
  
  
  yea = as.character(2004:2020)
  
  y = get.capturedata()
  x = get.path()
  
  names(x) = c("PID", "CID", "capdate", "kms")
  
  y$capdate = format(y$capdate, "%d/%m/%Y")
  y$sampdat = format(y$sampdat, "%d/%m/%Y")
  # y$capdate = format(y$capdate, format = "%d/%m/%Y")
  da = merge(x, y, by = c("PID","capdate"))
  
  ##REMOVE YEARS
  da = da[which(da$sampyear %in% yea),]
  da$sample_num = NULL
  da$sample_id = NULL
  da$trip = NULL
  da$trip_id = NULL
  da$captain = NULL
  da$Reported = NULL
  
  da$sample_id = NULL
  nr = nrow(da)
  
  
  if(nr == 0) return(z)
  names(da) = c("PID","capdat", "CID", "km", "caparea","caplat", "caplong",  "capyear", "relcode", "triparea", "sampyear", "sampdate", "samplat", "samplon")
  
  ii = absolutely.in.area2(are, da$samplon, da$samplat)
  #jj = absolutely.in.area2(are, da$caplon, da$caplat)
  # ind = which(!(ii | jj))
  ind = which(!ii)
  
  if(length(ind)>0) 
    da = da[-ind,]
  
  if(rm.gulf){
    #REMOVE GULF ENTRIES
    #ind = which( as.character(da$caparea) == "GULF" & as.character(da$triparea) == "GULF"  )
    ind = which(as.character(da$triparea) == "GULF"  & as.numeric(as.character(da$sampyear)) <= 2014 )
    if(length(ind)>0) 
      da = da[-ind,]
  }
  
  dup = unique(da[which(duplicated(da$PID)),]$PID)
  
  recaps = da[which(da$PID %in% dup),]
  
  length(unique(recaps$PID))
  length(which(da$relcode == "1"))
  
  #######################################################################
  
  
  cdd = get.capturedata()
  cdd$abscaparea = absolutely.in.area2(area = "unknown", abslon = cdd$caplon, abslat = cdd$caplat)
  cdd$abssamparea = absolutely.in.area2(area = "unknown", abslon = cdd$rellon, abslat = cdd$rellat)
  print(cdd[which(cdd$abscaparea == "NENS" & cdd$abssamparea == "SENS"),])
  print(cdd[which(cdd$abscaparea == "SENS" & cdd$abssamparea == "NENS"),])
  
  cdd4x = cdd[which(cdd$abssamparea == "CFA-4X" & as.numeric(as.character(cdd$sampyear)) >= 2008 ),]
  counts = as.data.frame(table(as.character(cdd4x$PID)))
  which(counts$Freq > 1)
  which(counts$Freq > 2)
  
  print(cdd[which(cdd$abscaparea == "CFA-4X" & cdd$abssamparea == "SENS"),])
  print(cdd[which(cdd$abscaparea == "SENS" & cdd$abssamparea == "CFA-4X"),])
  
  cp = get.path()
  cp$CDATE = lubridate::dmy(cp$CDATE)
  ad = merge(cp, cdd, by.x = c("TID", "CDATE"), by.y = c("PID", "capdate") )
  
  #######################################################################
  
  
  
  y = get.capturedata()
  x = get.path()
  
  names(x) = c("PID", "CID", "capdate", "kms")
  
  
  y$capdate = format(y$capdate, "%d/%m/%Y")
  y$sampdat = format(y$sampdat, "%d/%m/%Y")
  # y$capdate = format(y$capdate, format = "%d/%m/%Y")
  da = merge(x, y, by = c("PID","capdate"))
  
  da$caparea = absolutely.in.area2("unknown", da$caplon, da$caplat)
  da$area = absolutely.in.area2("unknown", da$rellon, da$rellat)
  da$days = dmy(da$capdate) - dmy(da$sampdat)
  da$yr = year(dmy(da$sampdat))
  da$kms = as.numeric(da$kms)
  da = da[- which(as.numeric(da$caplon) == 0),]
  da = da[- which(da$days < 10),]
  
  ggplot2.scatterplot(data=da, backgroundColor="white", size=5, xName='days',yName='kms', groupName="area", legendTitle = "Release Area", xtickLabelRotation = 90)
  
  da$year.group = NA
  #da$year.group = "0-2003"
  da$year.group[which(da$yr >= 2004 & da$yr <= 2008)] = "2004-2008"
  da$year.group[which(da$yr >= 2009 & da$yr <= 2013)] = "2009-2013"
  da$year.group[which(da$yr >= 2014)] = "2014-2019"
  ind = which(is.na(da$year.group))
  if(length(ind>0)) da = da[-ind,]
  ind = which(is.na(da$area))
  if(length(ind)>0)da = da[-ind,]
  
  da = da[which(is.finite(da$days)),]
  
  da = da[which(da$area != "GULF"),]
  
  ggplot2.scatterplot(data=da, backgroundColor="white", mainTitle="Kilometers vs. Days by Release Area", size=5, xName='days',yName='kms', groupName="area", faceting=TRUE, facetingVarNames="year.group", legendTitle = "Release Area", facetingDirection="vertical", xtickLabelRotation = 90, addRegLine=TRUE, regLineColor="blue",addConfidenceInterval=TRUE, smoothingMethod="loess")
  
  
  #################################################################################
  drv <- dbDriver("Oracle")
  con <- ROracle::dbConnect(drv, username = oracle.snowcrab.user, password = oracle.snowcrab.password, dbname = oracle.snowcrab.server)
  
  
  respat <- ROracle::dbSendQuery(con, "select * from SCT_ACCOUSTIC_PATH")
  respat <- ROracle::fetch(respat)
  respath <- ROracle::dbSendQuery(con, "select * from SCT_ACCOUSTIC_PATHS")
  respath <- ROracle::fetch(respath)
  respat$caplat = NA
  respat$caplon = NA
  respat$rellat = NA
  respat$rellon = NA
  for(i in 1:nrow(respat)){
    df = respath[which(respath$PID == respat$PID[i] & respath$CID == respat$CID[i]),]
    respat$rellat[i] = df$LAT[1]
    respat$rellon[i] = df$LONG[1]
    respat$caplat[i] = df$LAT[nrow(df)]
    respat$caplon[i] = df$LONG[nrow(df)]
  }
  
  respat$relarea = absolutely.in.area2("unknown", respat$rellon, respat$rellat)
  respat$caparea = absolutely.in.area2("unknown", respat$caplon, respat$caplat)
  respat$DIST = as.numeric(respat$DIST)
  respat$DAYS = difftime(respat$EDATE,respat$SDATE)
  
  
  
  y$capdate = format(y$capdate, "%d/%m/%Y")
  y$sampdat = format(y$sampdat, "%d/%m/%Y")
  # y$capdate = format(y$capdate, format = "%d/%m/%Y")
  da = merge(x, y, by = c("PID","capdate"))
  
  da$caparea = absolutely.in.area2("unknown", da$caplon, da$caplat)
  da$area = absolutely.in.area2("unknown", da$rellon, da$rellat)
  da$days = dmy(da$capdate) - dmy(da$sampdat)
  da$yr = year(dmy(da$sampdat))
  da$kms = as.numeric(da$kms)
  da = da[- which(as.numeric(da$caplon) == 0),]
  da = da[- which(da$days < 10),]
  
  ggplot2.scatterplot(data=da, backgroundColor="white", size=5, xName='days',yName='kms', groupName="area", legendTitle = "Release Area", xtickLabelRotation = 90)
  
  da$year.group = NA
  #da$year.group = "0-2003"
  da$year.group[which(da$yr >= 2004 & da$yr <= 2008)] = "2004-2008"
  da$year.group[which(da$yr >= 2009 & da$yr <= 2013)] = "2009-2013"
  da$year.group[which(da$yr >= 2014)] = "2014-2019"
  ind = which(is.na(da$year.group))
  if(length(ind>0)) da = da[-ind,]
  ind = which(is.na(da$area))
  if(length(ind)>0)da = da[-ind,]
  
  da = da[which(is.finite(da$days)),]
  
  da = da[which(da$area != "GULF"),]
  
  ggplot2.scatterplot(data=da, backgroundColor="white", mainTitle="Kilometers vs. Days by Release Area", size=5, xName='days',yName='kms', groupName="area", faceting=TRUE, facetingVarNames="year.group", legendTitle = "Release Area", facetingDirection="vertical", xtickLabelRotation = 90, addRegLine=TRUE, regLineColor="blue",addConfidenceInterval=TRUE, smoothingMethod="loess")
  
  
  #################################################################################
  drv <- dbDriver("Oracle")
  con <- ROracle::dbConnect(drv, username = oracle.snowcrab.user, password = oracle.snowcrab.password, dbname = oracle.snowcrab.server)
  
  
  respat <- ROracle::dbSendQuery(con, "select * from SCT_ACCOUSTIC_PATH")
  respat <- fetch(respat)
  respath <- ROracle::dbSendQuery(con, "select * from SCT_ACCOUSTIC_PATHS")
  respath <- fetch(respath)
  respat$caplat = NA
  respat$caplon = NA
  respat$rellat = NA
  respat$rellon = NA
  for(i in 1:nrow(respat)){
    df = respath[which(respath$PID == respat$PID[i] & respath$CID == respat$CID[i]),]
    respat$rellat[i] = df$LAT[1]
    respat$rellon[i] = df$LONG[1]
    respat$caplat[i] = df$LAT[nrow(df)]
    respat$caplon[i] = df$LONG[nrow(df)]
  }
  
  respat$relarea = absolutely.in.area2("unknown", respat$rellon, respat$rellat)
  respat$caparea = absolutely.in.area2("unknown", respat$caplon, respat$caplat)
  respat$DIST = as.numeric(respat$DIST)
  respat$DAYS = difftime(respat$EDATE,respat$SDATE)
  
  
  #NEXT CHUNCK ONLY TEMPORARY
  #ercid = respat$PID[which(respat$DIST > 300)]
  #respat = respat[-which(respat$PID %in% ercid),] 
  
  
  ggplot2.scatterplot(data=respat, backgroundColor="white", size=5, xName='DAYS',yName='DIST', groupName="relarea", legendTitle = "Release Area", xtickLabelRotation = 90)
  
  
  ROracle::dbDisconnect(con)
  rel = get.acoustic.releases()
  det = get.acoustic.detections()
  rel$relarea = absolutely.in.area2("unknown", rel$RELEASE_LONGITUDE, rel$RELEASE_LATITUDE)
  unique(rel$relarea)
  arl = read.csv("C:/SCtagging/output/arel.csv")
  apa = read.csv("C:/SCtagging/output/acpath.csv")
  names(apa) = c("rows", "id", "Days", "PID", "Km")
  apa$id = gsub("ZSC-", "", apa$id)
  apa$Area = NA
  
  arl$Area = absolutely.in.area2("unknown", arl$lon, arl$lat)
  
  for(i in 1:nrow(apa)){
    apa$Area[i] = arl$Area[which(arl$ANIMAL_ID == apa$id[i])]
    
  }
  
  ggplot2.scatterplot(data=apa, backgroundColor="white", size=5, xName='Days',yName='Km', groupName="Area", legendTitle = "Release Area", xtickLabelRotation = 90)
  
  
  
  ad$DIST = as.numeric(ad$DIST)
  
  ad$Days = ad$CDATE - as.Date(ad$sampdat)
  ad$Days = as.numeric(ad$Days)
  ad$Sample.Area = ad$abssamparea
  
  ad$Km = ad$DIST
  xc = unlist(rainbow(length(unique(ad$sampyear))+3))
  xc = xc[4:length(xc)]
  #dt  = ad[which(ad$Sample.Area!='GULF'),]
  dt  = ad[which(ad$Days > 10),]
  dt  = dt[which(dt$caplat != 0),]
  dt  = dt[which(dt$abssamparea != "GULF"),]
  avli = sum(dt$DIST)/sum(dt$Days)
  avd = dt$Days*avli
  dt$year.group = NA
  # dt$year.group[which(dt$sampyear >= 1996 & dt$sampyear <= 1998)] = "1996-1998"
  # dt$year.group[which(dt$sampyear >= 1999 & dt$sampyear <= 2003)] = "1999-2003"
  # dt$year.group[which(dt$sampyear >= 2004 & dt$sampyear <= 2008)] = "2004-2008"
  # dt$year.group[which(dt$sampyear >= 2009 & dt$sampyear <= 2013)] = "2009-2013"
  # dt$year.group[which(dt$sampyear >= 2014)] = "2014-2017"
  
  dt$year.group[which(dt$sampyear >= 2004 & dt$sampyear <= 2008)] = "2004-2008"
  dt$year.group[which(dt$sampyear >= 2009 & dt$sampyear <= 2013)] = "2009-2013"
  dt$year.group[which(dt$sampyear >= 2014)] = "2014-2018"
  ind = which(is.na(dt$year.group))
  if(length(ind>0)) dt = dt[-ind,]
  
  
  ggplot2.scatterplot(data=dt, backgroundColor="white", size=5, xName='Days',yName='Km', groupName="Sample.Area", faceting=TRUE, facetingVarNames="year.group", legendTitle = "Release Area", facetingDirection="vertical", xtickLabelRotation = 90, addRegLine=TRUE, regLineColor="blue",addConfidenceInterval=TRUE, smoothingMethod="loess")
  
  ggplot2.scatterplot(data=dt, backgroundColor="white", mainTitle="Kilometers vs. Days by Release Area", xName='Days',yName='Km', groupName="Sample.Area", addRegLine=TRUE, regLineColor="blue",addConfidenceInterval=TRUE, smoothingMethod="loess")
  ggplot2.scatterplot(data=dt, backgroundColor="white", size=5, mainTitle="Kilometers vs. Days by Release Area", groupColors=xc, xName='Days',yName='Km', groupName="sampyear", faceting=TRUE, facetingVarNames="Sample.Area")
  plot(avli, type="l")
  
  
  
  dt$relarea = absolutely.in.area2("unknown", dt$rellon, dt$rellat)
  dt$caparea2 = absolutely.in.area2("unknown", dt$caplon, dt$caplat)
  
  ggplot2.barplot(data=dt[which(dt$relarea == "SENS"),], xName='relarea', yName="caparea2", position=position_dodge())
  
}


capture.history.spa= function(region = "ScotianShelf"){
  mcform = get.releases()
  cd = get.capturedata.oracle()
  
  mcform$begin.time = NA
  mcform$initial.age = NA
  mcform$time.intervals = NA
  mcform$ch = NA
  
  for(i in 1: nrow(mcform)){
    mcform$begin.time[i] = ymd(mcform$sampdat[i])
    mcform$initial.age[i] = mcform$cc[i]
    subcd = cd[which(cd$PID == mcform$PID[i]),]
    print(subcd)
    ch = h = c(1, 0, 0, 0, 0, 0, 0)
    h[as.numeric(subcd$year) - as.numeric(unique(subcd$sampyear[1])) +1] = 1
    mcform$ch[i] = paste(h, collapse = "")
    
    if(nrow(subcd)>0){
      yearlis = c()
      for(j in 1:nrow(subcd)){
        if(!subcd$year[j] %in% yearlis){
          yearlis = c(yearlis, subcd$year[j])
          if(is.na(mcform$time.intervals[i])){
            print(subcd$capdate[j] - subcd$sampdat[j])
            mcform$time.intervals[i] = subcd$capdate[j] - subcd$sampdat[j]
          }
          else{
            mcform$time.intervals[i] = c(mcform$time.intervals[i], subcd$capdate[j] - subcd$sampdat[j])
          }
          
        }
      }
    }
  }
  mc = mcform
  begin.time = mc$begin.time
  initial.age = mc$initial.age
  time.intervals =  mc$time.intervals
  mc$begin.time = NULL
  mc$initial.age = NULL
  mc$time.intervals = NULL
  x=process.data(data = mc, initial.ages = initial.age, time.intervals = time.intervals )
  x=process.data(data = mc, initial.ages = initial.age )
  
  x = process.data(data = mc)
  resight.matrix(y)
  
  naive.survival(x)
  
  mcmc_mode(x)
  accumulate_data(mc)
  
}




#' @title  get.capturedata.oracle
#' @description  Get all tag data view from oracle database 
#' @import ROracle DBI
#' @return dataframe of data
#' @export
get.capturedata.oracle = function(){
  gstring= ""
  drv <- DBI::dbDriver("Oracle")
  con <- ROracle::dbConnect(drv, username = oracle.snowcrab.user, password = oracle.snowcrab.password, dbname = oracle.snowcrab.server)
  res <- ROracle::dbSendQuery(con, paste("select * from SCT_ALL", gstring, sep = "")) 
  res <- ROracle::fetch(res)
  
  names(res) = c("PID", "caplat", "caplon", "capdate", "caparea", "year", "relcode","csubarea", "rewarded", "sampdat", "area", "subarea", "sampyear","samplat", "samplon", "carapace", "chela", "cc")
  
  
  return(res)
  
}

#' @title  Shortest Paths 
#' @description  Creates and writes the shortest paths to database
#' @param rasterpath The canvas on which to calculate shortest path, defaults to depth raster.
#' @param neighborhood The number of adjacent cell over which to calculate, defaults to 16.
#' @param type The type of calculation, either 'random.walk' or 'least.cost'. Defaults to random.walk
#' @param redo Set redo = TRUE if you want to rewrite all data, FALSE to only update new entries
#' @param region Either 'ScotianShelf' or 'Gulf'
#' @import PBSmapping raster gdistance ROracle RMySQL rJava DBI
#' @return dataframe
#' @export
shortestpaths.SC = function(raster.path = system.file("extdata", "depthraster2.tif", package = "SCtagging"), neighborhood = 16, type = "random.walk", redo = F, region = "ScotianShelf"){
  drv <- DBI::dbDriver("Oracle")
  gstring = ""
  if(region == "Gulf") gstring = "_GULF"
  x = get.capturedata(region)
  x$PID = as.character(x$PID)
  # x$capdate = as.POSIXct(as.numeric(as.character(x$capdate)), origin = "1960-01-01") 
  trans = NULL
  r = raster(raster.path)
  mr = as.matrix(r)
  mr[which(mr>-280 & mr< -60)] = -170
  mr = apply(mr, 2, function(x) dnorm(x,mean=-170,sd=60))
  r = setValues(r, mr)
  
  tr <- transition(r, mean, neighborhood)
  if(type  == "random.walk"){
    trans = geoCorrection(tr, type = "r", scl=FALSE)
  }
  if(type  == "least.cost"){
    trans = geoCorrection(tr, type = "c", scl=FALSE)
  }
  # 
  # local_port = "3309"
  # SCtunnel = openportSC(local.port = local_port)
  # 
  # con <- dbConnect(dbDriver("MySQL"), user = paste(enssnowc.user, "_admin", sep = ""), password = enssnowc.password, dbname = "enssnowc_Taging",  port = as.numeric(local_port), host = "localhost")
  # 
  
  
  
  
  #rs <- dbSendQuery(con, statement = "Select * from paths;")
  
  #da <- fetch(rs, n = -1)   # extract all rows
  
  # dbDisconnect(con) 
  # closeportSC(SCtunnel)
  # 
  dftowrite = NULL
  df2towrite = NULL
  dxtowrite = NULL
  
  if(!redo){
    
    con <- ROracle::dbConnect(drv, username = oracle.snowcrab.user, password = oracle.snowcrab.password, dbname = oracle.snowcrab.server)
    respat <- ROracle::dbSendQuery(con, "select * from SCT_PATH") 
    da <-  ROracle::fetch(respat)
    ROracle::dbDisconnect(con)
    
    goodind = which(paste(as.character(x$PID), format(x$capdate, "%d/%m/%Y")) %in% paste(as.character(da$TID), as.character(da$CDATE)))
    if(length(goodind) > 0) x = x[-goodind,]
    zeroind = which(as.numeric(x$caplat) == 0 | x$caplat == 'unknown')
    if(length(zeroind) > 0) x = x[-zeroind,]
    
    count = 1
    previd = ""
    if(nrow(x) == 0)message("No new paths to create!")
    else{
      for(i in 1:nrow(x)){
        if(x$PID[i] == previd){
          count = count+1
        }
        else{
          previd = x$PID[i]
          count = 1
        }
        start <- c(as.numeric(x$rellon[i]), as.numeric(x$rellat[i]))
        end <- c(as.numeric(x$caplon[i]), as.numeric(x$caplat[i]))
        
        if(abs(start[1] - end[1]) < res(trans)[1] && abs(start[2] - end[2]) < res(trans)[1] || is.na(cellFromXY(r, start)) || is.na(cellFromXY(r, end))){
          AtoB = rbind(start, end)
        }
        else{
          AtoB = shortestPath(trans, start, end, output="SpatialLines")
        }
        cor = data.frame(coordinates(AtoB))
        names(cor) = c("x", "y")
        xrep = cor$x[1]
        yrep = cor$y[1]
        for(k in 1:(nrow(cor)-1)){
          
          if(cor$x[k] == xrep){ cor$x[k] = start[1] }
          else{ xrep = 1000000 }
          
          if(cor$y[k] == yrep){ cor$y[k] =  start[2] }
          else{ yrep = 1000000 }
        }
        xrep = cor$x[nrow(cor)]
        yrep = cor$y[nrow(cor)]
        for(k in nrow(cor):2){
          if(cor$x[k] == xrep) cor$x[k] =  end[1]
          else xrep = 1000000
          
          if(cor$y[k] == yrep) cor$y[k] =  end[2]
          else yrep = 1000000
        }
        
        names(cor) = c("X", "Y")
        cor$PID = 1
        cor$POS = 1:nrow(cor)
        tpoly = as.PolySet(cor, projection = "LL")
        leng = calcLength (tpoly, rollup = 3, close = FALSE) #km    
        
        
        dxp = cbind(rep(x$PID[i], nrow(cor)),rep(count, nrow(cor)), 1:nrow(cor), cor$X, cor$Y)
        dxtowrite = rbind(dxtowrite, dxp)
        df2towrite = rbind(df2towrite, cbind(x$PID[i], count, as.character(x$capdat[i]), leng$length))
        
        dftowrite = rbind(dftowrite, cbind(x$PID[i],paste(cor[,1], collapse = ","), paste(cor[,2], collapse = ","), as.character(x$capdat[i]), leng$length))
        
      }
    }
    
  }
  else{
    count  = 1
    previd = ""
    for(i in 1:nrow(x)){
      if(x$PID[i] == previd){
        count = count+1
      }
      else{
        previd = x$PID[i]
        count = 1
      }
      start <- c(as.numeric(x$rellon[i]), as.numeric(x$rellat[i]))
      end <- c(as.numeric(x$caplon[i]), as.numeric(x$caplat[i]))
      
      if(abs(start[1] - end[1]) < res(trans)[1] && abs(start[2] - end[2]) < res(trans)[1] || is.na(cellFromXY(r, start)) || is.na(cellFromXY(r, end))){
        AtoB = rbind(start, end)
      }
      else{
        AtoB = shortestPath(trans, start, end, output="SpatialLines")
      }
      cor = data.frame(coordinates(AtoB))
      names(cor) = c("x", "y")
      xrep = cor$x[1]
      yrep = cor$y[1]
      for(k in 1:(nrow(cor)-1)){
        
        if(cor$x[k] == xrep){ cor$x[k] = start[1] }
        else{ xrep = 1000000 }
        
        if(cor$y[k] == yrep){ cor$y[k] =  start[2] }
        else{ yrep = 1000000 }
      }
      xrep = cor$x[nrow(cor)]
      yrep = cor$y[nrow(cor)]
      for(k in nrow(cor):2){
        if(cor$x[k] == xrep){ cor$x[k] =  end[1] }
        else{ xrep = 1000000 }
        
        if(cor$y[k] == yrep){ cor$y[k] =  end[2] }
        else{ yrep = 1000000}
      }
      
      names(cor) = c("X", "Y")
      cor$PID = 1
      cor$POS = 1:nrow(cor)
      tpoly = as.PolySet(cor, projection = "LL")
      leng = calcLength (tpoly, rollup = 3, close = FALSE) #km    
      
      dxp = cbind(rep(x$PID[i], nrow(cor)),rep(count, nrow(cor)), 1:nrow(cor), cor$X, cor$Y)
      dxtowrite = rbind(dxtowrite, dxp)
      df2towrite = rbind(df2towrite, cbind(x$PID[i], count, as.character(x$capdat[i]), leng$length))
      
      dftowrite = rbind(dftowrite, cbind(x$PID[i],paste(cor[,1], collapse = ","), paste(cor[,2], collapse = ","), as.character(x$capdat[i]), leng$length))
      
      
    }
    
  }
  
  if(!is.null(dftowrite)){
    dftowrite = data.frame(dftowrite)
    df2towrite = data.frame(df2towrite)
    
    names(dftowrite) = c("ID", "LON", "LAT", "CDATE", "DIST")
    names(df2towrite) = c("TID", "CID", "CDATE", "DIST")
    dxtowrite = data.frame(dxtowrite)
    names(dxtowrite) = c("TID", "CID", "POS", "LON", "LAT")
    drv <- DBI::dbDriver("Oracle")
    
    Sys.setenv(TZ = "America/Halifax")
    Sys.setenv(ORA_SDTZ = "America/Halifax")
    str(dftowrite$CDATE)
    dftowrite$CDATE = as.POSIXct(dftowrite$CDATE, origin = '1970-01-01')
    df2towrite$CDATE = as.POSIXct(df2towrite$CDATE, origin = '1970-01-01')
    
    
    xx= NULL
    xy=NULL
    xx = as.character(as.Date(dftowrite$CDATE))
    xx[which(is.na(xx))] = "1111-11-11"
    xy = matrix(unlist(strsplit(xx, "-")), ncol = 3,  byrow = T)
    
    dftowrite$CDATE = paste(xy[,3], xy[,2], xy[,1], sep = "/")
    dftowrite$CDATE[which(dftowrite$CDATE == "11/11/1111")] = NA
    
    xx= NULL
    xy=NULL
    xx = as.character(as.Date(df2towrite$CDATE))
    xx[which(is.na(xx))] = "1111-11-11"
    xy = matrix(unlist(strsplit(xx, "-")), ncol = 3,  byrow = T)
    
    df2towrite$CDATE = paste(xy[,3], xy[,2], xy[,1], sep = "/")
    df2towrite$CDATE[which(df2towrite$CDATE == "11/11/1111")] = NA
    
    
    con <- dbConnect(drv, username = oracle.snowcrab.user, password = oracle.snowcrab.password, dbname = oracle.snowcrab.server)
    if(redo){
      dbWriteTable(con,"SCT_PATHS", dxtowrite, overwrite = T)
      dbWriteTable(con,"SCT_PATH", df2towrite, overwrite = T)
      
    }
    else{
      dbWriteTable(con,"SCT_PATHS", dxtowrite, append = T)
      dbWriteTable(con,"SCT_PATH", df2towrite, append = T)
    }
    dbDisconnect(con)
    print("New paths calculated and written to paths table.")
  }
  else{
    print("No new paths created.")  
  }
  return(dftowrite)
}


#' @title  create.tag.kml.2
#' @description  Write tag movement data to kml. 
#' @param filename path to write the resulting kml
#' @import chron sp geosphere stringr kmlbuilder
#' @export
create.tag.kml.2 = function(write =T, preview = T, tofile = NULL ){
  samps <- get.releases()
  names(samps) = c("PID", "cc", "cw", "ch", "dur", "inArea","inFolder", "date", "lat", "lon")
  
  samps$inFolder = paste("rel_", samps$inFolder, sep = "") 
  da = get.capturedata()
  
  da$sample_num = NULL
  da$trip_id = NULL
  da$captain = NULL
  da$Reported = NULL
  
  da$sample_id = NULL
  
  names(da) = c("PID", "capdate", "caparea","caplat", "caplon", "year", "area", "sampyear", "sampdat", "samplat", "samplon")
  
  
  X=NULL
  Y=NULL
  PID=NULL
  POS=NULL
  colour=NULL
  ddif = NULL
  ddate = NULL
  ind = which(as.character(da$caplat) == "0")
  da = da[-ind,]
  
  ind = which(as.character(da$year) == "")
  if(length(ind) > 0 )da = da[-ind,]
  ind = which(as.character(da$area) == "GULF"  & as.numeric(as.character(da$sampyear)) <= 2014 )
  #ind = which(as.character(da$caparea) == "GULF" & as.character(da$area) == "GULF")
  
  da = da[-ind,]
  dup = 0
  
  
  
  mattxt = "unknown"
  
  ind = which(as.character(da$year) == mattxt)
  
  if(length(ind)>0) 
    da = da[-ind,]
  
  mattxt = "unknown unknown"
  
  ind = which(as.character(da$year) == mattxt)
  
  if(length(ind)>0) 
    da = da[-ind,]
  
  
  da = da[order(da$capdat),]
  outframe = NULL
  outarrow = NULL
  jsfinal = ""
  dx = split(da, da$sampyear)
  for(i in 1:length(dx)){
    #markernum = 0
    #ymain = main
    out = NULL
    da_y = dx[[i]]
    
    #ymain = sub("..year..", da_y$sampyear[1], ymain)
    
    da_tid = split(da_y, as.character(da_y$PID))
    #allmarkers = ""
    for(j in 1:length(da_tid)){
      fin_da = da_tid[[j]]
      
      sampchron = chron(as.character(fin_da$sampdat[1]), format = "y-m-d")
      
      # fin_path = path[which(path$id == fin_da$PID[1]),]
      fin_path = get.pathdata.tid(region = "ScotianShelf", tid = fin_da$PID[1])
      fin_path = unique( fin_path[ , 1:ncol(fin_path) ] )
      fin_path$CID = as.numeric(fin_path$CID)
      fin_path$POS = as.numeric(fin_path$POS)
      fin_path = fin_path[order(fin_path$CID, fin_path$POS),]
      markerblock = ""
      sub_out = NULL
      description = "<![CDATA[<b> datetxt  <br><br> disttxt</b>]]>"
      disttxt = ""
      datetxt = ""
      tid = ""
      
      for(k in 1:length(unique(fin_path$CID))){
        
        
        capchron = chron(as.character(fin_da$capdate[k]), format = "y-m-d")
        
        date = as.character(fin_da$capdate[k])
        
        if(is.na(capchron)){
          date = paste("No date returned, received in ",fin_da$year[k])
          if( as.character(fin_da$caparea[k]) == "NENS") capchron = chron(paste( as.character(fin_da$year[k]),"-07-15", sep=""), format = "y-m-d")
          if( as.character(fin_da$caparea[k]) == "SENS") capchron = chron(paste( as.character(fin_da$year[k]),"-08-15", sep=""), format = "y-m-d")
          if( as.character(fin_da$caparea[k]) == "GULF") capchron = chron(paste( as.character(fin_da$year[k]),"-08-15", sep=""), format = "y-m-d")
          if( as.character(fin_da$caparea[k]) == "4X") capchron = chron(paste( as.character(fin_da$year[k]),"-03-15", sep=""), format = "y-m-d")
          
        }
        dif = capchron - sampchron
        dif = as.numeric(dif)
        # arrls = "ls[0]"
        # cc2 = ""
        # if(is.na(dif)){ arrls = "ls[0]"
        # cc2 = "000000" 
        # } 
        # else if(dif < 180){ arrls = "ls[1]"
        # cc2 = "ff0000"
        # }
        # else if(dif < 545){ arrls = "ls[2]"
        # cc2 = "00aa00"
        # }
        # else if(dif < 1090){ arrls = "ls[3]"
        # cc2 = "0000ff"
        # }
        # else if(dif < 1455){ arrls = "ls[4]"
        # cc2 = "ffff00"
        # }
        # else{ 
        #   arrls = "ls[5]"
        #   cc2 = "55007f"
        # }
        cc = ""
        hr = ""
        lst = ""
        if(is.na(dif)){ 
          cc = "000000"
          hr = "http://enssnowcrab.com/R/tag/go/blarrow.png"
          lst = "lsc1"
        } else if(dif < 180) { 
          cc = "0000ff" 
          hr = "http://enssnowcrab.com/R/tag/go/rarrow.png"
          lst = "lsc2"
        } else if(dif < 545) { 
          #cc = "003800" 
          cc = "00AA00" 
          #hr = "http://enssnowcrab.com/R/tag/go/dgarrow.png" 
          hr = "http://enssnowcrab.com/R/tag/go/garrow.png" 
          lst = "lsc3"
        } else if(dif < 1090){ 
          cc = "ff0000" 
          hr = "http://enssnowcrab.com/R/tag/go/barrow.png"
          lst = "lsc4"
        } else if(dif < 1455) { 
          cc = "00ffff" 
          hr = "http://enssnowcrab.com/R/tag/go/yarrow.png"
          lst = "lsc5"
        } else{ 
          cc = "7f0055" 
          hr = "http://enssnowcrab.com/R/tag/go/parrow.png" 
          lst = "lsc6"
        }
        
        
        
        #lon = unlist(str_split(fin_path[k,]$lon, ","))
        #lat = unlist(str_split(fin_path[k,]$lat, ","))
        lon = fin_path$LON[which(fin_path$CID == k)]
        lat = fin_path$LAT[which(fin_path$CID == k)]
        
        if(k==1){
          
          disx = cbind(as.numeric(lon), as.numeric(lat))
          names(disx) = c("lon", "lat")
          
          leng = as.matrix(disx)
          leng = Line(leng)
          llen =  LineLength(leng, longlat = T)
          #dist = (distVincentyEllipsoid(dx, a=6378137, b=6356752.3142, f=1/298.257223563))/1000
          #dist = distVincentySphere(c(chunk$X[k-1],chunk$Y[k-1]), c(chunk$X[k],chunk$Y[k]), r=6378137)
          disttxt = paste("DISPLACEMENT: <br>   From release to 1st capture: ", signif(llen, digits=3), "km <br>", sep = "")
          if(grepl("No date", date)){
            datetxt = paste("TAG NUMBER:",fin_da$PID[1], "<br>TAGGED ON: ", as.character(chron(sampchron, out.format = "m d yyyy")), " <br>CAPTURED ON: ", date, sep = "")
          } else {
            datetxt = paste("TAG NUMBER:",fin_da$PID[1], "<br>TAGGED ON: ", as.character(chron(sampchron, out.format = "m d yyyy")), " <br>CAPTURED ON: ", as.character(chron(as.chron(date), out.format = "m d yyyy")), sep = "")
          }
          bearfro = (length(lon)-3) : length(lon)
          bearfro = bearfro[bearfro > 0]
          
          icon_heading = bearing(p1 = c(as.numeric(lon[bearfro[1]]),as.numeric(lat[bearfro[1]] )), p2 = c(as.numeric(lon[bearfro[length(bearfro)]]),as.numeric(lat[bearfro[length(bearfro)]] )))
          
          
        }
        if(k>1){
          
          disx = cbind(as.numeric(lon), as.numeric(lat))
          names(disx) = c("lon", "lat")
          leng = as.matrix(disx)
          leng = Line(leng)
          llen =  LineLength(leng, longlat = T)
          
          #dist = (distVincentyEllipsoid(dx, a=6378137, b=6356752.3142, f=1/298.257223563))/1000
          #dist = distVincentySphere(c(chunk$X[k-1],chunk$Y[k-1]), c(chunk$X[k],chunk$Y[k]), r=6378137)
          disttxt = paste(disttxt, "<br>   To next capture:", signif(llen, digits=3), "km ") 
          if(grepl("No date", date)){
            datetxt = paste(datetxt, "<br>   CAPTURED AGAIN ON: ", date, sep = "")
          } else {
            datetxt = paste(datetxt, "<br>   CAPTURED AGAIN ON: ", as.character(chron(as.chron(date), out.format = "m d yyyy")), sep = "")
          }
          bearfro = (length(lon)-3) : length(lon)
          bearfro = bearfro[bearfro > 0]
          icon_heading = bearing(p1 = c(as.numeric(lon[bearfro[1]]),as.numeric(lat[bearfro[1]] )), p2 = c(as.numeric(lon[bearfro[length(bearfro)]]),as.numeric(lat[bearfro[length(bearfro)]] )))
          
        }
        pid = paste(fin_da$PID[k], k, sep = ".")
        line_color = rep(cc, length(lon))
        icon_href = rep(hr, length(lon))
        #line_href = rep(lst, length(lon))
        if(is.null(sub_out)){
          sub_out = data.frame(cbind(pid, lon, lat, line_color, line_width = 2))
        }else{
          sub_out = rbind(sub_out, cbind(pid, lon, lat, line_color, line_width = 2))
        }
        
        
        
        if(is.null(outarrow)){
          outarrow = data.frame(cbind(pid, da_y$sampyear[1], lon[length(lon)], lat[length(lat)], icon_heading, hr, .4))
        }else{
          outarrow = rbind(outarrow, cbind(pid, da_y$sampyear[1], lon[length(lon)], lat[length(lat)],icon_heading, hr, .4))
        }
        
        # ymarker = markers
        # tespos = paste(paste("{lat: ", lat, ",lng: ", lon, "}", sep = ""), collapse = ",")
        # ymarker = sub("..positions..", tespos, ymarker)
        # ymarker = sub("..color..", cc2, ymarker)     
        # ymarker = gsub("..arindex..", markernum, ymarker)
        # ymarker = sub("..ls..", arrls, ymarker)
        # markernum = markernum + 1
        # markerblock = paste(markerblock, ymarker, sep=" 
        #                     ")
        
        
      }
      
      description = sub("disttxt", disttxt, description)
      description = sub("datetxt", datetxt, description)
      sub_out$description = description
      sub_out$POS = 1:nrow(sub_out)
      
      
      if(is.null(out)){
        out = sub_out
      }else{
        out = rbind(out, sub_out)
      }
      
      
    }
    
    out$inFolder = da_y$sampyear[1]
    
    
    
    if(is.null(outframe)){
      outframe = out
    }else{
      outframe = rbind(outframe, out)
    }
    
    #   ymain = sub("..markers..", allmarkers, ymain)
    # jsfinal = paste(jsfinal, ymain, sep = "
    #                   ")
    
    
    
  }
  require(kmlbuilder)
  outframe$pid = gsub("G", "9999", outframe$pid)
  mykml = RKmlObject()
  
  
  mykml$addIconStyle(styleid = "iconstyle1", color = "yellow", href = "http://maps.google.com/mapfiles/kml/shapes/shaded_dot.png", scale = .4)
  
  
  mykml$addFolder(fid = "Releases", name = "Releases") 
  mykml$addPoint(samps, styleUrl = "iconstyle1")
  
  mykml$addLineStyle(styleid = "lsc1", color = "000000", width = 15)
  mykml$addLineStyle(styleid = "lsc2", color = "0000ff", width = 15)
  #mykml$addLineStyle(styleid = "lsc3", color = "003800", width = 8)
  mykml$addLineStyle(styleid = "lsc3", color = "00AA00", width = 15)
  mykml$addLineStyle(styleid = "lsc4", color = "ff0000", width = 15)
  mykml$addLineStyle(styleid = "lsc5", color = "00ffff", width = 15)
  mykml$addLineStyle(styleid = "lsc6", color = "7f0055", width = 15)
  
  names(outarrow) = c("pid", "inFolder", "lon", "lat", "icon_heading", "icon_href", "icon_scale")
  
  mykml$addPoint(outarrow)
  mykml$addLineString(outframe, altitudeMode = "relativeToGround")
  
  #mykml$addScreenOverlay(fn = "E:\\SCtagging\\data\\taglegend.png", size_x = .2, size_y = .2, screen_x = .8, screen_y = .8 )
  
  if(preview){
    mykml$preview()
  }
  if(write){
    if(is.null(tofile)){
      mykml$writekml(path = file.path(getwd(), "kml_outputs", "SCtagging_kml_2.kml"))
    }
    else{
      mykml$writekml(path = tofile)
      
    }
  }
  
  # if(is.null(filename)){
  #   sink("jsfinal.js")
  #   cat(jsfinal)
  #   sink()
  # }
  # else{
  #   sink(filename)
  #   cat(jsfinal)
  #   sink()  
  # }
  
}


#' @title  create.tag.kml
#' @description  Function that generates a kml plot of tag data 
#' @param preview Boolean default TRUE
#' @param write Boolean default TRUE
#' @param tofile path to write the resulting kml
#' @import RMySQL chron geosphere kmlbuilder
#' @export
create.tag.kml = function(preview = T, write = T, tofile = NULL){
  require(kmlbuilder)
  local_port = "3308"
  SCtunnel = openportSC(local.port = local_port)
  
  
  con <- dbConnect(RMySQL::MySQL(), user = paste(enssnowc.user, "_admin", sep = ""), password = enssnowc.password, dbname = "enssnowc_Taging",  port = as.numeric(local_port), host = "localhost")
  rs <- dbSendQuery(con, statement = "SET SQL_BIG_SELECTS = 1;")
  rs <- dbSendQuery(con, statement = "Select * from 
                    (SELECT  bio.tag_id, bio.sample_num, str_to_date( capture.date, '%d/%m/%Y' ) date, capture.statsarea, capture.lat_DD_DDDD, capture.long_DD_DDDD, capture.year 
                    from capture join bio where bio.tag_id = capture.tag) t1 
                    JOIN (SELECT trip.trip_id, trip.statsarea, trip.year, trip.captain, trip.Reported, str_to_date( trip.date, '%d/%m/%Y' ) date, sample.lat_DD_DDDD, sample.long_DD_DDDD, sample.sample_id
                    from trip join sample where sample.trip = trip.trip_id)t2
                    ON t1.sample_num = t2.sample_id  
                    ORDER BY captain, trip_id, tag_id, t1.date;")
  
  da <- fetch(rs, n = -1)   # extract all rows
  
  rs <- dbSendQuery(con, statement = "Select * from paths;")
  
  path <- fetch(rs, n = -1)   # extract all rows
  
  sa <- dbSendQuery(con, statement = "SELECT trip.trip_id, trip.statsarea, trip.year, str_to_date( trip.date, '%d/%m/%Y' ) date, sample.lat_DD_DDDD, sample.long_DD_DDDD, sample.sample_id
                    from trip join sample where sample.trip = trip.trip_id ;")
  
  samps <- fetch(sa, n = -1)   # extract all rows
  
  closeportSC(SCtunnel)
  dbDisconnect(con)
  
  names(samps) = c("area", "inArea","inFolder", "date", "lat", "lon", "unk")
  
  samps$inFolder = paste("rel_", samps$inFolder, sep = "") 
  
  
  da$sample_id = NULL
  
  da$trip_id = NULL
  
  
  
  
  
  
  names(path) = c("id","lon", "lat", "cdat", "dist")
  
  path = path[order(path$cdat),]
  
  da$sample_num = NULL
  da$trip_id = NULL
  da$captain = NULL
  da$Reported = NULL
  
  da$sample_id = NULL
  
  names(da) = c("PID", "capdate", "caparea","caplat", "caplon", "year", "area", "sampyear", "sampdat", "samplat", "samplon")
  
  
  X=NULL
  Y=NULL
  PID=NULL
  POS=NULL
  colour=NULL
  ddif = NULL
  ddate = NULL
  ind = which(as.character(da$caplat) == "0")
  da = da[-ind,]
  
  ind = which(as.character(da$year) == "")
  if(length(ind) > 0 )da = da[-ind,]
  
  ind = which(as.character(da$caparea) == "GULF" & as.character(da$area) == "GULF")
  
  da = da[-ind,]
  dup = 0
  
  mattxt = "unknown"
  
  ind = which(as.character(da$year) == mattxt)
  
  if(length(ind)>0) 
    da = da[-ind,]
  
  mattxt = "unknown unknown"
  
  ind = which(as.character(da$year) == mattxt)
  
  if(length(ind)>0) 
    da = da[-ind,]
  
  
  da = da[order(da$capdat),]
  outframe = NULL
  outarrow = NULL
  
  dx = split(da, da$sampyear)
  for(i in 1:length(dx)){
    
    
    out = NULL
    da_y = dx[[i]]
    
    
    da_tid = split(da_y, da_y$PID)
    
    for(j in 1:length(da_tid)){
      fin_da = da_tid[[j]]
      sampchron = chron(fin_da$sampdat[1], format = "y-m-d")
      
      
      
      fin_path = path[which(path$id == fin_da$PID[1]),]
      sub_out = NULL
      description = "<![CDATA[<b> datetxt  <br><br> disttxt</b>]]>"
      disttxt = ""
      datetxt = ""
      tid = ""
      
      for(k in 1:nrow(fin_path)){
        capchron = chron(  fin_da$capdate[k], format = "y-m-d")
        
        date = as.character(   fin_da$capdate[k])
        
        if(is.na(capchron)){
          date = paste("No date returned, received in ",fin_da$year[k])
          if( fin_da$caparea[k] == "NENS") capchron = chron(paste( fin_da$year[k],"-07-15", sep=""), format = "y-m-d")
          if( fin_da$caparea[k] == "SENS") capchron = chron(paste( fin_da$year[k],"-08-15", sep=""), format = "y-m-d")
          if( fin_da$caparea[k] == "GULF") capchron = chron(paste( fin_da$year[k],"-08-15", sep=""), format = "y-m-d")
          if( fin_da$caparea[k] == "4X") capchron = chron(paste( fin_da$year[k],"-03-15", sep=""), format = "y-m-d")
          
        }
        dif = capchron - sampchron
        dif = as.numeric(dif)
        
        cc = ""
        hr = ""
        lst = ""
        if(is.na(dif)){ cc = "000000"
        hr = "http://enssnowcrab.com/R/tag/go/blarrow.png"
        lst = "lsc1"
        } 
        else if(dif < 180){ cc = "0000ff" 
        hr = "http://enssnowcrab.com/R/tag/go/rarrow.png"
        lst = "lsc2"
        }
        else if(dif < 545){ 
          #cc = "003800" 
          cc = "00AA00" 
          #hr = "http://enssnowcrab.com/R/tag/go/dgarrow.png" 
          hr = "http://enssnowcrab.com/R/tag/go/garrow.png" 
          lst = "lsc3"
        }
        else if(dif < 1090){ cc = "ff0000" 
        hr = "http://enssnowcrab.com/R/tag/go/barrow.png"
        lst = "lsc4"
        }
        else if(dif < 1455){ cc = "00ffff" 
        hr = "http://enssnowcrab.com/R/tag/go/yarrow.png"
        lst = "lsc5"
        
        }
        else{ cc = "7f0055" 
        hr = "http://enssnowcrab.com/R/tag/go/parrow.png" 
        lst = "lsc6"
        }
        
        
        
        lon = unlist(str_split(fin_path[k,]$lon, ","))
        lat = unlist(str_split(fin_path[k,]$lat, ","))
        dist = "unknown"
        
        if(k==1){
          
          disx = cbind(as.numeric(lon), as.numeric(lat))
          names(disx) = c("lon", "lat")
          leng = as.matrix(disx)
          leng = Line(leng)
          llen =  LineLength(leng, longlat = T)
          #dist = (distVincentyEllipsoid(dx, a=6378137, b=6356752.3142, f=1/298.257223563))/1000
          #dist = distVincentySphere(c(chunk$X[k-1],chunk$Y[k-1]), c(chunk$X[k],chunk$Y[k]), r=6378137)
          disttxt = paste("DISPLACEMENT: <br>   From release to 1st capture: ", signif(llen, digits=3), "km <br>", sep = "")
          if(grepl("No date", date))
            datetxt = paste("TAG NUMBER:",fin_da$PID[1], "<br>TAGGED ON: ", as.character(chron(sampchron, out.format = "m d yyyy")), " <br>CAPTURED ON: ", date, sep = "")
          else
            datetxt = paste("TAG NUMBER:",fin_da$PID[1], "<br>TAGGED ON: ", as.character(chron(sampchron, out.format = "m d yyyy")), " <br>CAPTURED ON: ", as.character(chron(as.chron(date), out.format = "m d yyyy")), sep = "")
          bearfro = (length(lon)-3) : length(lon)
          bearfro = bearfro[bearfro > 0]
          
          icon_heading = bearing(p1 = c(as.numeric(lon[bearfro[1]]),as.numeric(lat[bearfro[1]] )), p2 = c(as.numeric(lon[bearfro[length(bearfro)]]),as.numeric(lat[bearfro[length(bearfro)]] )))
          
          
        }
        if(k>1){
          
          disx = cbind(as.numeric(lon), as.numeric(lat))
          names(disx) = c("lon", "lat")
          leng = as.matrix(disx)
          leng = Line(leng)
          llen =  LineLength(leng, longlat = T)
          
          #dist = (distVincentyEllipsoid(dx, a=6378137, b=6356752.3142, f=1/298.257223563))/1000
          #dist = distVincentySphere(c(chunk$X[k-1],chunk$Y[k-1]), c(chunk$X[k],chunk$Y[k]), r=6378137)
          disttxt = paste(disttxt, "<br>   To next capture:", signif(llen, digits=3), "km ") 
          if(grepl("No date", date))
            datetxt = paste(datetxt, "<br>   CAPTURED AGAIN ON: ", date, sep = "")
          else
            datetxt = paste(datetxt, "<br>   CAPTURED AGAIN ON: ", as.character(chron(as.chron(date), out.format = "m d yyyy")), sep = "")
          bearfro = (length(lon)-3) : length(lon)
          bearfro = bearfro[bearfro > 0]
          icon_heading = bearing(p1 = c(as.numeric(lon[bearfro[1]]),as.numeric(lat[bearfro[1]] )), p2 = c(as.numeric(lon[bearfro[length(bearfro)]]),as.numeric(lat[bearfro[length(bearfro)]] )))
          
        }
        
        
        
        pid = paste(fin_da$PID[k], k, sep = ".")
        
        line_color = rep(cc, length(lon))
        icon_href = rep(hr, length(lon))
        #line_href = rep(lst, length(lon))
        if(is.null(sub_out)){
          sub_out = data.frame(cbind(pid, lon, lat, line_color, line_width = 2))
        }else{
          sub_out = rbind(sub_out, cbind(pid, lon, lat, line_color, line_width = 2))
        }
        
        
        if(is.null(outarrow)){
          outarrow = data.frame(cbind(pid, da_y$sampyear[1], lon[length(lon)], lat[length(lat)], icon_heading, hr, .4))
        }else{
          outarrow = rbind(outarrow, cbind(pid, da_y$sampyear[1], lon[length(lon)], lat[length(lat)],icon_heading, hr, .4))
        }
        
      }
      
      description = sub("disttxt", disttxt, description)
      description = sub("datetxt", datetxt, description)
      sub_out$description = description
      sub_out$POS = 1:nrow(sub_out)
      
      if(is.null(out)){
        out = sub_out
      }else{
        out = rbind(out, sub_out)
      }
      
      
    }
    
    out$inFolder = da_y$sampyear[1]
    
    if(is.null(outframe)){
      outframe = out
    }else{
      outframe = rbind(outframe, out)
    }
    
    
    
    
  }
  outframe$pid = gsub("G", "9999", outframe$pid)
  mykml = RKmlObject()
  
  
  mykml$addIconStyle(styleid = "iconstyle1", color = "yellow", href = "http://maps.google.com/mapfiles/kml/shapes/shaded_dot.png", scale = .4)
  
  
  mykml$addFolder(fid = "Releases", name = "Releases") #Demonstrate adding folder
  mykml$addPoint(samps, styleUrl = "iconstyle1")
  
  mykml$addLineStyle(styleid = "lsc1", color = "000000", width = 15)
  mykml$addLineStyle(styleid = "lsc2", color = "0000ff", width = 15)
  #mykml$addLineStyle(styleid = "lsc3", color = "003800", width = 8)
  mykml$addLineStyle(styleid = "lsc3", color = "00AA00", width = 15)
  mykml$addLineStyle(styleid = "lsc4", color = "ff0000", width = 15)
  mykml$addLineStyle(styleid = "lsc5", color = "00ffff", width = 15)
  mykml$addLineStyle(styleid = "lsc6", color = "7f0055", width = 15)
  
  names(outarrow) = c("pid", "inFolder", "lon", "lat", "icon_heading", "icon_href", "icon_scale")
  
  mykml$addPoint(outarrow)
  mykml$addLineString(outframe, altitudeMode = "relativeToGround")
  print(getwd())
  #mykml$addScreenOverlay(fn = "E:\\SCtagging\\data\\taglegend.png", size_x = .2, size_y = .2, screen_x = .8, screen_y = .8 )
  
  if(preview){
    mykml$preview()
  }
  if(write){
    if(is.null(tofile)){
      mykml$writekml(path = file.path(getwd(), "kml_outputs", "SCtagging_kml.kml"))
    }
    else{
      mykml$writekml(path = tofile)
      
    }
  }
  
}

#' @title  create.tag.geojson
#' @description  Write tag movement data to GeoJSON javascript functions. This is used by the enssnowcrab website to display tag movement data by year. The previous tag kml does not display properly in google maps so this method was implemented. It looks better than the old kml since geoJSON has built in arrow markers.
#' @param filename path to write the resulting kml
#' @import RMySQL chron sp geosphere stringr
#' @export
create.tag.geojson = function(filename = NULL){
  
  main = "function add..year..(map, arr, inf, ls){..markers..}" 
  markers = "arr[..arindex..] = new google.maps.Polyline({strokeColor: '#..color..', strokeWeight: 2, path: [..positions..], icons: [{ icon: ..ls.., offset: '100%'}], map: map}); arr[..arindex..].addListener('click', function(event) { inf.setContent('..description..'); inf.position = event.latLng; inf.open(map); inf.setPosition(event.latLng);});"
  positions = "{lat: ..lat.., lng: ..lon..}"
  
  
  # local_port = "3308"
  # SCtunnel = openportSC(local.port = local_port)
  # 
  # 
  # con <- dbConnect(dbDriver("MySQL"), user = paste(enssnowc.user, "_admin", sep = ""), password = enssnowc.password, dbname = "enssnowc_Taging",  port = as.numeric(local_port), host = "localhost")
  # rs <- dbSendQuery(con, statement = "SET SQL_BIG_SELECTS = 1;")
  # rs <- dbSendQuery(con, statement = "Select * from 
  #                   (SELECT  bio.tag_id, bio.sample_num, str_to_date( capture.date, '%d/%m/%Y' ) date, capture.statsarea, capture.lat_DD_DDDD, capture.long_DD_DDDD, capture.year 
  #                   from capture join bio where bio.tag_id = capture.tag) t1 
  #                   JOIN (SELECT trip.trip_id, trip.statsarea, trip.year, trip.captain, trip.Reported, str_to_date( trip.date, '%d/%m/%Y' ) date, sample.lat_DD_DDDD, sample.long_DD_DDDD, sample.sample_id
  #                   from trip join sample where sample.trip = trip.trip_id)t2
  #                   ON t1.sample_num = t2.sample_id  
  #                   ORDER BY captain, trip_id, tag_id, t1.date;")
  # 
  # da <- fetch(rs, n = -1)   # extract all rows
  da = get.capturedata()
  
  # rs <- dbSendQuery(con, statement = "Select * from paths;")
  
  #path <- fetch(rs, n = -1)   # extract all rows
  # closeportSC(SCtunnel)
  # dbDisconnect(con)
  
  # names(path) = c("id","lon", "lat", "cdat", "dist")
  
  # path = path[order(path$cdat),]
  
  da$sample_num = NULL
  da$trip_id = NULL
  da$captain = NULL
  da$Reported = NULL
  
  da$sample_id = NULL
  
  names(da) = c("PID", "capdate", "caparea","caplat", "caplon", "year","relcode", "area", "sampyear", "sampdat", "samplat", "samplon")
  
  
  X=NULL
  Y=NULL
  PID=NULL
  POS=NULL
  colour=NULL
  ddif = NULL
  ddate = NULL
  ind = which(as.character(da$caplat) == "0")
  da = da[-ind,]
  
  ind = which(as.character(da$year) == "")
  if(length(ind) > 0 )da = da[-ind,]
  ind = which(as.character(da$area) == "GULF"  & as.numeric(as.character(da$sampyear)) <= 2014 )
  #ind = which(as.character(da$caparea) == "GULF" & as.character(da$area) == "GULF")
  
  da = da[-ind,]
  dup = 0
  
  
  
  mattxt = "unknown"
  
  ind = which(as.character(da$year) == mattxt)
  
  if(length(ind)>0) 
    da = da[-ind,]
  
  mattxt = "unknown unknown"
  
  ind = which(as.character(da$year) == mattxt)
  
  if(length(ind)>0) 
    da = da[-ind,]
  
  
  da = da[order(da$capdat),]
  outframe = NULL
  outarrow = NULL
  jsfinal = ""
  dx = split(da, da$sampyear)
  for(i in 1:length(dx)){
    markernum = 0
    ymain = main
    out = NULL
    da_y = dx[[i]]
    
    ymain = sub("..year..", da_y$sampyear[1], ymain)
    
    da_tid = split(da_y, as.character(da_y$PID))
    allmarkers = ""
    for(j in 1:length(da_tid)){
      fin_da = da_tid[[j]]
      
      sampchron = chron(as.character(fin_da$sampdat[1]), format = "y-m-d")
      
      # fin_path = path[which(path$id == fin_da$PID[1]),]
      fin_path = get.pathdata.tid(region = "ScotianShelf", tid = fin_da$PID[1])
      fin_path = unique( fin_path[ , 1:ncol(fin_path) ] )
      fin_path$CID = as.numeric(fin_path$CID)
      fin_path$POS = as.numeric(fin_path$POS)
      fin_path = fin_path[order(fin_path$CID, fin_path$POS),]
      description2 = "<b> datetxt  <br><br> disttxt</b>"
      disttxt = ""
      datetxt = ""
      tid = ""
      markerblock = ""
      
      
      for(k in 1:length(unique(fin_path$CID))){
        
        
        capchron = chron(as.character(fin_da$capdate[k]), format = "y-m-d")
        
        date = as.character(fin_da$capdate[k])
        
        if(is.na(capchron)){
          date = paste("No date returned, received in ",fin_da$year[k])
          if( as.character(fin_da$caparea[k]) == "NENS") capchron = chron(paste( as.character(fin_da$year[k]),"-07-15", sep=""), format = "y-m-d")
          if( as.character(fin_da$caparea[k]) == "SENS") capchron = chron(paste( as.character(fin_da$year[k]),"-08-15", sep=""), format = "y-m-d")
          if( as.character(fin_da$caparea[k]) == "GULF") capchron = chron(paste( as.character(fin_da$year[k]),"-08-15", sep=""), format = "y-m-d")
          if( as.character(fin_da$caparea[k]) == "4X") capchron = chron(paste( as.character(fin_da$year[k]),"-03-15", sep=""), format = "y-m-d")
          
        }
        dif = capchron - sampchron
        dif = as.numeric(dif)
        arrls = "ls[0]"
        cc2 = ""
        if(is.na(dif)){ arrls = "ls[0]"
        cc2 = "000000" 
        } 
        else if(dif < 180){ arrls = "ls[1]"
        cc2 = "ff0000"
        }
        else if(dif < 545){ arrls = "ls[2]"
        cc2 = "00aa00"
        }
        else if(dif < 1090){ arrls = "ls[3]"
        cc2 = "0000ff"
        }
        else if(dif < 1455){ arrls = "ls[4]"
        cc2 = "ffff00"
        }
        else{ 
          arrls = "ls[5]"
          cc2 = "55007f"
        }
        
        
        
        #lon = unlist(str_split(fin_path[k,]$lon, ","))
        #lat = unlist(str_split(fin_path[k,]$lat, ","))
        lon = fin_path$LON[which(fin_path$CID == k)]
        lat = fin_path$LAT[which(fin_path$CID == k)]
        
        if(k==1){
          
          disx = cbind(as.numeric(lon), as.numeric(lat))
          names(disx) = c("lon", "lat")
          
          leng = as.matrix(disx)
          leng = Line(leng)
          llen =  LineLength(leng, longlat = T)
          #dist = (distVincentyEllipsoid(dx, a=6378137, b=6356752.3142, f=1/298.257223563))/1000
          #dist = distVincentySphere(c(chunk$X[k-1],chunk$Y[k-1]), c(chunk$X[k],chunk$Y[k]), r=6378137)
          disttxt = paste("DISPLACEMENT: <br>   From release to 1st capture: ", signif(llen, digits=3), "km <br>", sep = "")
          if(grepl("No date", date))
            datetxt = paste("TAG NUMBER:",fin_da$PID[1], "<br>TAGGED ON: ", as.character(chron(sampchron, out.format = "m d yyyy")), " <br>CAPTURED ON: ", date, sep = "")
          else
            datetxt = paste("TAG NUMBER:",fin_da$PID[1], "<br>TAGGED ON: ", as.character(chron(sampchron, out.format = "m d yyyy")), " <br>CAPTURED ON: ", as.character(chron(as.chron(date), out.format = "m d yyyy")), sep = "")
          
          
        }
        if(k>1){
          
          disx = cbind(as.numeric(lon), as.numeric(lat))
          names(disx) = c("lon", "lat")
          leng = as.matrix(disx)
          leng = Line(leng)
          llen =  LineLength(leng, longlat = T)
          
          #dist = (distVincentyEllipsoid(dx, a=6378137, b=6356752.3142, f=1/298.257223563))/1000
          #dist = distVincentySphere(c(chunk$X[k-1],chunk$Y[k-1]), c(chunk$X[k],chunk$Y[k]), r=6378137)
          disttxt = paste(disttxt, "<br>   To next capture:", signif(llen, digits=3), "km ") 
          if(grepl("No date", date))
            datetxt = paste(datetxt, "<br>   CAPTURED AGAIN ON: ", date, sep = "")
          else
            datetxt = paste(datetxt, "<br>   CAPTURED AGAIN ON: ", as.character(chron(as.chron(date), out.format = "m d yyyy")), sep = "")
          
        }
        
        ymarker = markers
        tespos = paste(paste("{lat: ", lat, ",lng: ", lon, "}", sep = ""), collapse = ",")
        ymarker = sub("..positions..", tespos, ymarker)
        ymarker = sub("..color..", cc2, ymarker)     
        ymarker = gsub("..arindex..", markernum, ymarker)
        ymarker = sub("..ls..", arrls, ymarker)
        markernum = markernum + 1
        markerblock = paste(markerblock, ymarker, sep=" 
                            ")
        
        pid = paste(fin_da$PID[k], k, sep = ".")
        
        
        
        
      }
      
      description2 = sub("disttxt", disttxt, description2)
      description2 = sub("datetxt", datetxt, description2)
      markerblock = gsub("..description..", description2, markerblock)
      
      
      
      allmarkers = paste(allmarkers, markerblock, sep = "
                         ")
      
    }
    ymain = sub("..markers..", allmarkers, ymain)
    jsfinal = paste(jsfinal, ymain, sep = "
                    ")
    
    
    
  }
  if(is.null(filename)){
    sink("jsfinal.js")
    cat(jsfinal)
    sink()
  }
  else{
    sink(filename)
    cat(jsfinal)
    sink()  
  }
  
}

tags.poly.intersect.plot = function(){
  
  da = get.capturedata()
  
  
  da$sample_num = NULL
  da$trip_id = NULL
  da$captain = NULL
  da$Reported = NULL
  
  da$sample_id = NULL
  
  names(da) = c("PID", "capdate", "caparea","caplat", "caplon", "year", "area", "sampyear", "sampdat", "samplat", "samplon")
  
  
  X=NULL
  Y=NULL
  PID=NULL
  POS=NULL
  colour=NULL
  
  ind = which(as.character(da$caplat) == "0.0")
  if(length(ind)>0) da = da[-ind,]
  ind = which(as.character(da$caplat) == "0")
  if(length(ind)>0) da = da[-ind,]
  
  ii = is.in(are, da$samplon, da$samplat)
  jj = is.in(are, da$caplon, da$caplat)
  ind = which(!(ii | jj))
  
  if(length(ind)>0) 
    da = da[-ind,]
  
  #REMOVE GULF ENTRIES
  ind = which( as.character(da$caparea) == "GULF" & as.character(da$area) == "GULF"  )
  if(length(ind)>0) 
    da = da[-ind,]
  
  
  library(stringr)
  yea = years
  syear = da$sampyear
  if(years != "all"){
    years = strsplit(years, ",")
    years = unlist(years)
    
    syear = match(syear, years)
    
    indic = which(is.na(syear) == TRUE)
    
    if(length(indic)>0) 
      da = da[-indic,]
    
  }
  mattxt = "unknown"
  
  ind = which(as.character(da$year) == mattxt)
  
  if(length(ind)>0) 
    da = da[-ind,]
  
  
  
  
  
  dup = NULL
  for (i in 1:nrow(da)) {
    
    if(i > 1){
      if(da$PID[i] != da$PID[i-1]){
        dup = 1
        
        X = c(X, da$samplon[i])
        Y = c(Y, da$samplat[i])
        POS = c(POS, dup[1])
        PID = c(PID, da$PID[i])
        colour = c(colour, "white")
      }
      sampchron = chron(da$sampdat[i], format = "y-m-d")
      capchron = chron(da$capdat[i], format = "y-m-d")
      
      if(is.na(capchron)){
        if(da$caparea[i] == "NENS") capchron = chron(paste(da$year[i],"-07-15", sep=""), format = "y-m-d")
        if(da$caparea[i] == "SENS") capchron = chron(paste(da$year[i],"-08-15", sep=""), format = "y-m-d")
        if(da$caparea[i] == "GULF") capchron = chron(paste(da$year[i],"-08-15", sep=""), format = "y-m-d")
        if(da$caparea[i] == "4X") capchron = chron(paste(da$year[i],"-03-15", sep=""), format = "y-m-d")
        
      }
      dif = capchron - sampchron
      dif = as.numeric(dif)
      
      cc = ""
      if(is.na(dif)){ cc = "black" } 
      else if(dif < 180){ cc = "red" }
      else if(dif < 545){ cc = "darkgreen" }
      else if(dif < 1090){ cc = "blue" }
      else if(dif < 1455){ cc = "darkgoldenrod2" }
      else{ cc = "purple"}
      dup = dup+1
      
      X = c(X, da$caplon[i])
      Y = c(Y, da$caplat[i])
      POS = c(POS, dup[1])
      PID = c(PID, da$PID[i])
      colour = c(colour, cc)
    }
    else{
      X = c(X,da$samplon[i])
      Y = c(Y,da$samplat[i])
      POS = c(POS, 1)
      PID = c(PID,da$PID[i])
      X = c(X, da$caplon[i])
      Y = c(Y, da$caplat[i])
      POS = c(POS, 2)
      PID = c(PID, da$PID[i])
      colour = c(colour, "white")
      
      sampchron = chron(da$sampdat[i], format = "y-m-d")
      capchron = chron(da$capdat[i], format = "y-m-d")
      
      if(is.na(capchron)){
        if(da$caparea[i] == "NENS") capchron = chron(paste(da$year[i],"-07-15", sep=""), format = "y-m-d")
        if(da$caparea[i] == "SENS") capchron = chron(paste(da$year[i],"-08-15", sep=""), format = "y-m-d")
        if(da$caparea[i] == "GULF") capchron = chron(paste(da$year[i],"-08-15", sep=""), format = "y-m-d")
        if(da$caparea[i] == "4X") capchron = chron(paste(da$year[i],"-03-15", sep=""), format = "y-m-d")
        
      }
      
      dif = capchron - sampchron
      dif = as.numeric(dif)
      
      cc = ""
      if(is.na(dif)){ cc = "black" } 
      else if(dif < 180){ cc = "red" }
      else if(dif < 545){ cc = "darkgreen" }
      else if(dif < 1090){ cc = "blue" }
      else if(dif < 1455){ cc = "darkgoldenrod2" }
      else{ cc = "purple"}
      colour = c(colour, cc)
      dup = 2
    }
  }
  co = c("black", "red", "darkgreen", "blue", "darkgoldenrod2", "purple")
  na = c("unknown" ,"same season", "1 season", "2 seasons", "3 seasons", "4+ seasons")
  cocode = cbind(co, na) 
  cocode = data.frame(cocode)
  dbDisconnect(con)
  
  x = cbind(PID, POS, X, Y, colour)
  x = data.frame(x)
  x$PID = as.character(x$PID)
  x$POS = trunc(as.numeric(as.character(x$POS)))
  x$X = as.numeric(as.character(x$X))
  x$Y = as.numeric(as.character(x$Y))
  
  
  icoco = match(as.character(cocode$co), as.character(unique(x$colour)))
  icoco = which(is.na(icoco) == TRUE)
  
  cocode = cocode[-icoco,]
  x$PID = as.numeric(x$PID)
  
  x$z = colour
  x = as.PolySet(data.frame(x), projection = "LL")
  
  dir = file.path("C:", "project","mapping", "maps", "Emera Line", "ENL_SubseaCable_2km_StudyArea.shp"  )
  el= importShapefile(dir)
  
  
  sp1 = PolySet2SpatialPolygons(el, close_polys=TRUE)
  sp2 = PolySet2SpatialLines(x)
  
  tlis = gCrosses(sp2, sp1, byid = T)
  
  sp2 = sp2[which(tlis == T),]
  
  x = SpatialLines2PolySet(sp2)
  
  xlim = c(min(x$X)-.2, max(x$X)+.2)
  ylim = c(min(x$Y)-.2, max(x$Y)+.2)
  plotRaster( file.path(direct,"mapping", "maps","Charts", "801_LL_WGS84_PCT.tif"),
              xlab="Longitude", main = paste("Snow Crab (Spaghetti) Emera Line Crossings | Year(s):", yea, sep=" "), ylab="Latitude", outer = T, axes=T, tck=0,
              fade = .5, cex.main = .5, tckLab=F, xlim = xlim, ylim = ylim, quality = quality, cellcount = NULL)
  
  
  addlinesSCAREA(lwd = 1)
  addMPA()
  
  addDivisions(xlim, ylim)
  
  #addLines(x, col = "blue", cex = .5, arrows = T, length = .05)
  
  addPolys(el, col = rgb(.8, 0, 0, .3))
  #x = x[which(x$PID %in% pids),]
  
  
  
  
  for (i in 1:length(sp2)) {
    chunk = as.data.frame(unlist(coordinates(sp2[i]), recursive = F)[1])
    
    names(chunk) = c("X", "Y")
    
    dd = c("blue")
    
    if(!shortpath){
      arrows(x0 = chunk$X[1:length(chunk$X)-1], y0 =  chunk$Y[1:length(chunk$Y)-1], x1 = chunk$X[2:length(chunk$X)] , y1 = chunk$Y[2:length(chunk$Y)], col = dd, angle= 20, code=2, length = 0.06)
    }
    else{
      len = shortest(chunk$X, chunk$Y, dd)
      
      
    }
    
  }
}

recaps.plot = function(){
  
  da = get.capturedata()
  
  ##REMOVE YEARS
  da = da[which(da$sampyear %in%  as.character(years) ),]
  da$sample_num = NULL
  da$sample_id = NULL
  da$trip = NULL
  da$trip_id = NULL
  da$captain = NULL
  da$Reported = NULL
  
  da$sample_id = NULL
  
  
  mat = paste("(",are,")", sep = "")
  ind = which(!grepl(mat, da$subarea, fixed = TRUE))
  if(length(ind)>0)
    da = da[-ind,]
  
  #  
  #  ii = is.in(are, da$samplon, da$samplat)
  #  jj = is.in(are, da$caplon, da$caplat)
  #  ind = which(!(ii | jj))
  #  
  #  
  #  if(length(ind)>0) 
  #    da = da[-ind,]
  #  
  #  
  #REMOVE GULF ENTRIES
  ind = which(as.character(da$caparea) == "GULF" & as.character(da$triparea) == "GULF"  & as.numeric(as.character(da$sampyear)) <= 2014 )
  if(length(ind)>0) 
    da = da[-ind,]
  
  da$recap = 1 
  previd = ""
  # da = da[order(da$PID),]
  for(i in 1:nrow(da)){
    
    if(da$PID[i] == previd){
      da$recap[i] = da$recap[i-1] + 1
    }
    previd = da$PID[i] 
  }
  z = NULL
  z$ret = nrow(da)
  z$retuni = length(unique(da$PID))
  
  fr = da[which(da$area == "NENS" & da$caparea == "SENS"),]
  
}


#' @title  get.releases
#' @description  Return capture data
#' @import ROracle DBI
#' @return dataframe
#' @export
get.releases = function(region = "ScotianShelf"){
  
  tryCatch({
    drv <- DBI::dbDriver("Oracle")
    conn <- ROracle::dbConnect(drv, username = oracle.snowcrab.user, password = oracle.snowcrab.password, dbname = oracle.snowcrab.server)
  }, warning = function(w) {
  }, error = function(e) {
    return(toJSON("Connection failed"))
  }, finally = {
  })
  
  
  gstring = ""
  if(region == "Gulf"){
    gstring = "_GULF"
  }
  #con = RODBC::odbcConnect(oracle.snowcrab.server , uid=oracle.snowcrab.user, pwd=oracle.snowcrab.password, believeNRows=F)
  da = NULL
  
  
  query = paste("SELECT SCT_BIO", gstring,".TAG_ID,
                SCT_BIO", gstring,".SAMPLE_NUM,
                SCT_BIO", gstring,".CC,
                SCT_BIO", gstring,".CARAPACE_W,
                SCT_BIO", gstring,".CHELA_H,  
                SCT_BIO", gstring,".DUROMETER, 
                SCT_TRIP", gstring,".TRIP_ID,
                SCT_TRIP", gstring,".STATSAREA AS STATSAREA1,
                SCT_TRIP", gstring,".YEAR      AS YEAR1,
                SCT_TRIP", gstring,".RELEASE_DATE,
                SCT_SAMPLE", gstring,".LAT_DD_DDDD              AS LAT_DD_DDDD1,
                SCT_SAMPLE", gstring,".LONG_DD_DDDD             AS LONG_DD_DDDD1,
                SCT_SAMPLE", gstring,".SAMPLE_ID
                FROM SCT_BIO", gstring,"
                JOIN SCT_SAMPLE", gstring,"
                ON SCT_BIO", gstring,".SAMPLE_NUM = SCT_SAMPLE", gstring,".SAMPLE_ID
                INNER JOIN SCT_TRIP", gstring,"
                ON SCT_SAMPLE", gstring,".TRIP = SCT_TRIP", gstring,".TRIP_ID
                ORDER BY SCT_TRIP", gstring,".TRIP_ID,
                SCT_BIO", gstring,".TAG_ID,
                SCT_TRIP", gstring,".RELEASE_DATE", sep = "")
  
  resbio <- ROracle::dbSendQuery(conn, query) 
  da <- ROracle::fetch(resbio)
  #da = RODBC::sqlQuery(con, query )
  ROracle::dbDisconnect(conn)
  #RODBC::odbcClose(con)
  # da <- RODBC::fetch(rs, n = -1)   # extract all rows
  #RODBC::dbDisconnect(con) 
  # closeportSC(SCtunnel)
  da = unique(da)
  da$SAMPLE_NUM = NULL
  da$TRIP_ID = NULL
  da$SAMPLE_ID = NULL
  
  names(da) = c("PID", "cc", "cw", "ch", "dur", "area", "sampyear", "sampdat", "rellat", "rellon")
  
  return(da)
}
#' @title  get.capturedata
#' @description  Return capture data
#' @import ROracle DBI
#' @return dataframe
#' @export
get.capturedata = function(region = "ScotianShelf"){
  gstring = ""
  if(region == "Gulf"){
    gstring = "_GULF"
  }
   da = NULL
  
  
  query = paste("SELECT SCT_BIO", gstring,".TAG_ID,
                SCT_BIO", gstring,".SAMPLE_NUM,
                SCT_CAPTURE", gstring,".CAPTURE_DATE,
                SCT_CAPTURE", gstring,".STATSAREA,
                SCT_CAPTURE", gstring,".LAT_DD_DDDD,
                SCT_CAPTURE", gstring,".LONG_DD_DDDD,
                SCT_CAPTURE", gstring,".YEAR,
                SCT_CAPTURE", gstring,".RELCODE,
                SCT_TRIP", gstring,".TRIP_ID,
                SCT_TRIP", gstring,".STATSAREA AS STATSAREA1,
                SCT_TRIP", gstring,".YEAR      AS YEAR1,
                SCT_TRIP", gstring,".CAPTAIN,
                SCT_TRIP", gstring,".REPORTED,
                SCT_TRIP", gstring,".RELEASE_DATE,
                SCT_SAMPLE", gstring,".LAT_DD_DDDD              AS LAT_DD_DDDD1,
                SCT_SAMPLE", gstring,".LONG_DD_DDDD             AS LONG_DD_DDDD1,
                SCT_SAMPLE", gstring,".SAMPLE_ID
                FROM SCT_CAPTURE", gstring,"
                INNER JOIN SCT_BIO", gstring,"
                ON SCT_BIO", gstring,".TAG_ID = SCT_CAPTURE", gstring,".TAG
                INNER JOIN SCT_SAMPLE", gstring,"
                ON SCT_BIO", gstring,".SAMPLE_NUM = SCT_SAMPLE", gstring,".SAMPLE_ID
                INNER JOIN SCT_TRIP", gstring,"
                ON SCT_SAMPLE", gstring,".TRIP = SCT_TRIP", gstring,".TRIP_ID
                ORDER BY SCT_TRIP", gstring,".CAPTAIN,
                SCT_TRIP", gstring,".TRIP_ID,
                SCT_BIO", gstring,".TAG_ID,
                SCT_CAPTURE", gstring,".CAPTURE_DATE", sep = "")
  
  resbio <- ROracle::dbSendQuery(con, query) 
  da <-  ROracle::fetch(resbio)
 
  ROracle::dbDisconnect(con)

  da$CAPTURE_DATE = as.Date(da$CAPTURE_DATE)
  da$RELEASE_DATE = as.Date(da$RELEASE_DATE)
  da = unique(da)
  da$SAMPLE_NUM = NULL
  da$TRIP_ID = NULL
  da$CAPTAIN = NULL
  da$REPORTED = NULL
  da$SAMPLE_ID = NULL
  
  names(da) = c("PID", "capdate", "caparea","caplat", "caplon", "year","relcode", "area", "sampyear", "sampdat", "samplat", "samplon")
  previd = ""
  # da = da[order(da$PID),]
  for(i in 1:nrow(da)){
    if(da$PID[i] == previd){
      da$samplat[i] = da$caplat[i-1]
      da$samplon[i] = da$caplon[i-1]
      da$sampdat[i] = da$capdat[i-1]
    }
    previd = da$PID[i] 
  }
  
  names(da) = c("PID", "capdate", "caparea","caplat", "caplon", "year", "area","relcode", "sampyear", "sampdat", "rellat", "rellon")

  return(da)
  
}

#' @title  get.pathdata.tid
#' @description  Return calculated paths by supplied TID
#' @import ROracle
#' @return dataframe
#' @export
get.pathdata.tid = function(region = "ScotianShelf", tid = ""){
  gstring = ""
  if(region == "Gulf"){
    gstring = "_GULF"
  }
  
  drv <- DBI::dbDriver("Oracle")
  con <- ROracle::dbConnect(drv, username = oracle.snowcrab.user, password = oracle.snowcrab.password, dbname = oracle.snowcrab.server)
  
  #con = RODBC::odbcConnect(oracle.snowcrab.server , uid=oracle.snowcrab.user, pwd=oracle.snowcrab.password, believeNRows=F)
  da = NULL
  
  
  query = paste("SELECT * FROM SCT_PATHS", gstring, " where SCT_PATHS", gstring,".TID = '", tid, "'", sep = "")
  
  resbio <- ROracle::dbSendQuery(con, query) 
  da <- ROracle::fetch(resbio)
  
  #da = RODBC::sqlQuery(con, query )
  da = da[order(da$CID, da$POS),]
  #RODBC::odbcClose(con)
  ROracle::dbDisconnect(con)
  
  
  return(da)
  
}

#' @title  get.path
#' @description  Return path data
#' @import ROracle
#' @return dataframe
#' @export
get.path = function(region = "ScotianShelf"){
  gstring = ""
  if(region == "Gulf"){
    gstring = "_GULF"
  }
  
  
  drv <- DBI::dbDriver("Oracle")
  con <- ROracle::dbConnect(drv, username = oracle.snowcrab.user, password = oracle.snowcrab.password, dbname = oracle.snowcrab.server)
  
  
  respat <- ROracle::dbSendQuery(con, paste("select * from SCT_PATH", gstring, sep = ""))
  respat <-  ROracle::fetch(respat)
  ROracle::dbDisconnect(con)
  
  return(respat)
}

#' @title  data2Poly
#' @description  Create polydata
#' @import PBSmapping
#' @return dataframe
#' @export
data2Poly = function(da){
  out = NULL
  X = NULL
  Y = NULL
  D = NULL
  POS = NULL
  PID = NULL
  dup = NULL
  K = NULL
  for (i in 1:nrow(da)) {
    sampchron = as.character(da$sampdat[i])
    capchron = as.character(da$capdat[i])
    km = da$km[i]
    
    if(i > 1){
      
      if(da$PID[i] != da$PID[i-1]){
        dup = 1
        
        X = c(X, da$samplon[i])
        Y = c(Y, da$samplat[i])
        D = c(D, sampchron)
        POS = c(POS, dup[1])
        PID = c(PID, da$PID[i])
        K = c(K, 0)
      }
      
      dup = dup+1
      
      X = c(X, da$caplon[i])
      Y = c(Y, da$caplat[i])
      D = c(D, capchron)
      POS = c(POS, dup[1])
      PID = c(PID, da$PID[i])
      K = c(K, da$km[i])
      
    }
    else{
      X = c(X,da$samplon[i])
      Y = c(Y,da$samplat[i])
      D = c(D, sampchron)
      POS = c(POS, 1)
      PID = c(PID,da$PID[i])
      K = c(K, 0)
      X = c(X, da$caplon[i])
      Y = c(Y, da$caplat[i])
      D = c(D, capchron)
      POS = c(POS, 2)
      PID = c(PID, da$PID[i])
      K = c(K, da$km[i])
      dup = 2
      
    }
  }
  
  out = cbind(PID, POS, X, Y, D, K)
  out = data.frame(out)
  
  out$PID = as.character(out$PID)
  out$PID = as.numeric(gsub("G", "111111", out$PID))
  out$POS = trunc(as.numeric(as.character(out$POS)))
  out$X = as.numeric(as.character(out$X))
  out$Y = as.numeric(as.character(out$Y))
  out$K = as.numeric(as.character(out$K))
  #out = head(out,480)
  return(as.PolySet(out, projection = "LL"))
}
is.in = function(are2, lon, lat){
  lon = as.numeric(as.character(lon))
  lat = as.numeric(as.character(lat))
  fn =system.file("extdata", "areas", "areaborders.csv", package = "SCtagging")
  borders= read.csv(file=fn, head=T, sep=",")
  
  b=borders[which(borders$area==are2),]
  
  yli=c(b$slat,b$nlat)
  xli=c(-(b$wlon),-(b$elon))
  
  len = length(lon)
  ew = c(1:len)
  sn = c(1:len)
  fin = c(1:len)
  ew[1:len] = FALSE
  sn[1:len] = FALSE
  fin[1:len] = FALSE
  
  ew[(lon>xli[1]) & (lon<xli[2])] = TRUE
  
  sn[(lat>yli[1]) & (lat<yli[2])] = TRUE
  
  fin[(ew == TRUE) & (sn == TRUE)] = TRUE
  
  
  return(fin)
}


#' @title  absolutely.in.area
#' @description  Function that determins if a position is inside defined polygons 
#' @param area The area name exa. 'cfa23' 'cfa24' 'nens' 'sens' 'gulf' 'cfa4x'
#' @param lon The longitude of position in question
#' @param lat The latitude of position in question
#' @import sp rgeos
#' @return TRUE or FALSE
#' @export
absolutely.in.area = function(area, abslon, abslat){
  
  
  
  p1 = c(-60.41568418984078,47.03853523297152)
  p2 = c(-60.00014897319883,47.83408958793515 )
  p3 = c(-60, 50.3)
  p4 = c(-68, 50)
  p5 = c(-65.3, 44.25)
  p6 = c(-61, 46)
  p7 = c(-60.41568418984078,47.03853523297152)
  are = rbind(p1, p2, p3, p4, p5, p6, p7)
  
  
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  gulf = SpatialPolygons(list(paa), 1:1)
  
  
  
  p1 = c(-60.41568418984078,47.03853523297152)
  p2 = c(-60.00014897319883,47.83408958793515 )
  p3 = c(-57.5, 46)
  p4 = c(-57.78560987011954,46.00106076110973) 
  p5 = c(-59.85247480316924,46.00291960992756) 
  p6 = c(-61, 46)
  p7 = c(-60.41568418984078,47.03853523297152)
  are = rbind(p1, p2, p3, p4, p5, p6, p7)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  nens = SpatialPolygons(list(paa), 1:1)
  
  
  
  p1 = c(-57.78560987011954,46.00106076110973) 
  p2 = c(-59.85247480316924,46.00291960992756) 
  p3 = c(-61, 46)
  p4 = c(-60.66040620990439,45.58083805201212)
  p5 = c(-59.11881785180857,43.67610276909335)
  p6 = c(-56.5, 44)
  p7 = c(-57.78560987011954,46.00106076110973) 
  
  are = rbind(p1, p2, p3, p4, p5, p6, p7)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  twothree = SpatialPolygons(list(paa), 1:1)
  
  p1 = c(-61, 46)
  p2 = c(-60.66040620990439,45.58083805201212)
  p3 = c(-59.11881785180857,43.67610276909335)
  p4 = c(-63.33161397633095,42.50186912534272)
  p5 = c(-63.33296001561555,44.33343763428088)
  p6 = c(-63.52502801857509,44.5005704612574)
  p7 = c(-64, 45)
  p8 = c(-61, 46)
  are = rbind(p1, p2, p3, p4, p5, p6, p7, p8)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  twofour = SpatialPolygons(list(paa), 1:1)
  
  
  p1 = c(-63.52502801857509,44.5005704612574)
  p2 = c(-63.33296001561555,44.33343763428088)
  p3 = c(-63.33161397633095,42.50186912534272)
  p4 = c(-66.5, 42)
  p5 = c(-65, 45.5)
  p6 = c(-63.52502801857509,44.5005704612574)
  are = rbind(p1, p2, p3, p4, p5, p6)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  xxxx = SpatialPolygons(list(paa), 1:1)
  
  p1 = c(-61.4,44)
  p2 = c(-61.4,45.5)
  p3 = c(-58,45.5)
  p4 = c(-58,44)
  p5 = c(-61.4,44)
  are = rbind(p1, p2, p3, p4, p5)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  holes = SpatialPolygons(list(paa), 1:1)
  
  
  p1 = c(-62.5,43.8)
  p2 = c(-62.5,45.7)
  p3 = c(-59.2,45.7)
  p4 = c(-59.2,43.8)
  p5 = c(-62.5,43.8)
  are = rbind(p1, p2, p3, p4, p5)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  twofourz = SpatialPolygons(list(paa), 1:1)
  
  
  
  p1 = c(-60.6,44.1)
  p2 = c(-60.6,46.1)
  p3 = c(-57.75,46.1)
  p4 = c(-57.75,44.1)
  p5 == c(-60.6,44.1)
  are = rbind(p1, p2, p3, p4, p5)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  twothreez = SpatialPolygons(list(paa), 1:1)
  
  
  
  p1 = c(-60.41568418984078,47.03853523297152)
  p2 = c(-60.00014897319883,47.83408958793515 )
  p3 = c(-60, 50.3)
  p4 = c(-68, 50)
  p5 = c(-65.3, 44.25)
  p6 = c(-61, 46)
  p7 = c(-60.41568418984078,47.03853523297152)
  are = rbind(p1, p2, p3, p4, p5, p6, p7)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  gulf = SpatialPolygons(list(paa), 1:1)
  
  
  p1 = c(-60.41568418984078,47.03853523297152)
  p2 = c(-60.00014897319883,47.83408958793515 )
  p3 = c(-57.5, 46)
  p4 = c(-57.78560987011954,46.00106076110973) 
  p5 = c(-59.85247480316924,46.00291960992756) 
  p6 = c(-61, 46)
  p7 = c(-60.41568418984078,47.03853523297152)
  are = rbind(p1, p2, p3, p4, p5, p6, p7)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  nens = SpatialPolygons(list(paa), 1:1)
  
  
  p1 = c(-57.78560987011954,46.00106076110973) 
  p2 = c(-59.85247480316924,46.00291960992756) 
  p3 = c(-61, 46)
  p4 = c(-60.66040620990439,45.58083805201212)
  p5 = c(-59.11881785180857,43.67610276909335)
  p6 = c(-56.5, 44)
  p7 = c(-57.78560987011954,46.00106076110973) 
  are = rbind(p1, p2, p3, p4, p5, p6, p7)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  twothree = SpatialPolygons(list(paa), 1:1)
  
  p1 = c(-61, 46)
  p2 = c(-60.66040620990439,45.58083805201212)
  p3 = c(-59.11881785180857,43.67610276909335)
  p4 = c(-63.33161397633095,42.50186912534272)
  p5 = c(-63.33296001561555,44.33343763428088)
  p6 = c(-63.52502801857509,44.5005704612574)
  p7 = c(-64, 45)
  p8 = c(-61, 46)
  are = rbind(p1, p2, p3, p4, p5, p6, p7, p8)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  twofour = SpatialPolygons(list(paa), 1:1)
  
  
  p1 = c(-63.52502801857509,44.5005704612574)
  p2 = c(-63.33296001561555,44.33343763428088)
  p3 = c(-63.33161397633095,42.50186912534272)
  p4 = c(-66.5, 42)
  p5 = c(-65, 45.5)
  p6 = c(-63.52502801857509,44.5005704612574)
  are = rbind(p1, p2, p3, p4, p5, p6)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  xxxx = SpatialPolygons(list(paa), 1:1)
  
  p1 = c(-61.4,44)
  p2 = c(-61.4,45.5)
  p3 = c(-58,45.5)
  p4 = c(-58,44)
  p5 = c(-61.4,44)
  are = rbind(p1, p2, p3, p4, p5)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  holes = SpatialPolygons(list(paa), 1:1)
  
  
  p1 = c(-62.5,43.8)
  p2 = c(-62.5,45.7)
  p3 = c(-59.2,45.7)
  p4 = c(-59.2,43.8)
  p5 = c(-62.5,43.8)
  are = rbind(p1, p2, p3, p4, p5)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  twofourz = SpatialPolygons(list(paa), 1:1)
  
  
  
  
  p1 = c(-60.6,44.1)
  p2 = c(-60.6,46.1)
  p3 = c(-57.75,46.1)
  p4 = c(-57.75,44.1)
  p5 == c(-60.6,44.1)
  are = rbind(p1, p2, p3, p4, p5)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  twothreez = SpatialPolygons(list(paa), 1:1)
  
  
  
  pb = SpatialPoints(rbind(c(as.numeric(abslon), as.numeric(abslat))))
  
  
  
  # all.holes,44,45.5,61.4,58
  bo = FALSE
  if(area == "cfa23"){
    if(gContains(twothree, pb)) bo = TRUE
  }
  
  if(area == "cfa23zoom"){
    if(gContains(twothreez, pb)) bo = TRUE
  }
  if(area == "cfa24"){
    if(gContains(twofour, pb)) bo = TRUE
  }
  if(area == "cfa24zoom"){
    if(gContains(twofourz, pb)) bo = TRUE
  }
  if(area == "cfa4x"){
    if(gContains(xxxx, pb)) bo = TRUE
  }
  if(area == "nens"){
    if(gContains(nens, pb)) bo = TRUE
  }  
  if(area == "nens_gulf"){
    if(gContains(nens, pb) | gContains(gulf, pb)) bo = TRUE
  }  
  
  
  if(area == "sens"){
    if(gContains(twofour, pb) | gContains(twothree, pb)) bo = TRUE
  } 
  if(area == "gulf"){
    if(gContains(gulf, pb)) bo = TRUE
  } 
  if(area == "all" | area == "ens"){
    if(gContains(twofour, pb) | gContains(twothree, pb) | gContains(xxxx, pb) | gContains(nens, pb)) bo = TRUE
  }
  if(area == "allandgulf"){
    if(gContains(twofour, pb) | gContains(twothree, pb) | gContains(xxxx, pb) | gContains(nens, pb) | gContains(gulf, pb)) bo = TRUE
  }
  if(area == "all.holes"){
    if(gContains(holes, pb)) bo = TRUE
  }  
  
  
  return(bo)
  
}


#' @title degminsec2decdeg
#' @description  Function that converts degree minutes decimal seconds to decimal degrees 
#' @param ddmmss.ss The coordinate to convert
#' @return numeric converted coordinate
#' @import stringr
#' @export
degmin2decdeg = function(ddmmss.ss){
  dms = as.character(ddmmss.ss)
  neg = grepl("-", dms)
  dms = str_replace(dms, "-", "")
  decsec = unlist(strsplit(dms, "\\."))[2]
  if(is.na(decsec)) decsec = "0" 
  decsec = paste(".", decsec, sep = "") 
  degminsec = unlist(strsplit(dms, "\\."))[1]
  sec = substr(degminsec, nchar(degminsec)-1, nchar(degminsec))
  min = substr(degminsec, nchar(degminsec)-3, nchar(degminsec)-2)
  deg = substr(degminsec, 1, nchar(degminsec)-4)
  sec = as.numeric(decsec) + as.numeric(sec)
  decmin = as.numeric(min) + sec/60
  decdeg = as.numeric(deg) + decmin/60
  if(neg) decdeg = decdeg*-1
  return(decdeg)  
  
}


#' @title  absolutely.in.area2
#' @description  Function that determines if a list of positions are inside defined polygons 
#' @param area The area name exa. 'cfa23' 'cfa24' 'nens' 'sens' 'gulf' 'cfa4x'
#' @param lon The longitude list
#' @param lat The latitude list
#' @import sp rgeos rgdal
#' @return list of TRUE or FALSE values
#' @export
absolutely.in.area2 = function(area, abslon, abslat){
  polyredo = F
  are = rep("unk", length(abslat))
  
  # latlong =  "+proj=lcc +lat_1=49 +lat_2=77 +lat_0=63.390675 +lon_0=-91.86666666666666 +x_0=6200000 +y_0=3000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
  # latlong = "+init=epsg:4326"
  # latlong = "+init=epsg:3347 +proj=lcc +lat_1=49 +lat_2=77 +lat_0=63.390675 +lon_0=-91.86666666666666 +x_0=6200000 +y_0=3000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
  latlong = "+proj=longlat +datum=NAD27 +no_defs"
  # latlong = "+init=epsg:3347"
  
  p1 = c(-60.41568418984078,47.03853523297152)
  p2 = c(-60.00014897319883,47.83408958793515 )
  p3 = c(-60, 50.3)
  p4 = c(-68, 50)
  p5 = c(-65.3, 44.25)
  p6 = c(-61, 46)
  p7 = c(-60.41568418984078,47.03853523297152)
  are = rbind(p1, p2, p3, p4, p5, p6, p7)
  
  
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  gulf = SpatialPolygons(list(paa), 1:1)
  if(polyredo){
    SPDF = SpatialPolygonsDataFrame(gulf, data.frame(N = c("cfa_gulf"), row.names = c("s1")))
    proj4string(SPDF) = CRS(latlong)
    writeOGR(SPDF, layer = 'cfa_gulf', 'C:/temp', driver="ESRI Shapefile")
  }  
  
  
  
  
  
  
  #Points taken from schedule XI from Atlantic Fishery Regulations, 1985 (SOR/86-21)
  #https://laws-lois.justice.gc.ca/PDF/SOR-86-21.pdf
  
  
  p1 = c(-60.00,degmin2decdeg("475000.00")) #Northern point
  #Point #3 from PART IIB / PARTIE IIB CRAB FISHING AREAS
  p2 = c(degmin2decdeg("-580900.00"), degmin2decdeg("461700.00"))
  #Point #2 from PART IIB / PARTIE IIB CRAB FISHING AREAS
  p3 = c(degmin2decdeg("-574700.00"), 46) 
  #Point #5 from PART IIB / PARTIE IIB CRAB FISHING AREAS
  p4 = c(degmin2decdeg("-595100.00"),46) 
  #Point #8 from PART IIB / PARTIE IIB CRAB FISHING AREAS
  p5 = c(degmin2decdeg("-604732.00"), degmin2decdeg("-455725.00"))
  #Point #28 from PART III / PARTIE III CRAB FISHING AREAS
  p6 = c(degmin2decdeg("-602455.00"), degmin2decdeg("470215.00"))
  #Point #29 from PART III / PARTIE III CRAB FISHING AREAS
  p7 = c(degmin2decdeg("-601740.00"), degmin2decdeg("471625.00"))
  p8 = c(-60.00,degmin2decdeg("475000.00")) #Northern point
  are = rbind(p1, p2, p3, p4, p5, p6, p7, p8)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s2")
  nens = SpatialPolygons(list(paa), 1:1)
  
  SPDF = SpatialPolygonsDataFrame(nens, data.frame(N = c("cfa_20-22(n-ens)"), row.names = c("s2")))
  if(polyredo){
    proj4string(SPDF) = CRS(latlong)
    writeOGR(SPDF, layer = 'cfa20-22(N-ENS)', 'C:/temp', driver="ESRI Shapefile")
  }
  
  
  # 1)	      46?00'			     59?51'
  # 2)	      46?00'			     57?47'
  # 3)	      43?24' 			     54?48' THENCE ALONG THE BOUNDARY OF THE CANADIAN 200 MILE LIMIT TO
  # 4)	      41?05'			     57?30'
  # 5)	      45?37'			     60?31'
  # 6)	      46?00'			     59?51'
  #NOTE:	WHEN THE GEOGRAPHIC BOUNDARY OF AN AREA IS EXPRESSED IN LATITUDE AND LONGITUDE, THOSE POINT REFERENCES ARE BASED ON THE GEODESIC SYSTEM NORTH AMERICAN DATUM 1927 (NAD27).
  
  
  # Inside outside line east of 
  # p5 = c(-59.38666666666666666666667 43.9186111111111111111116666667)	
  #p6 = c(-56.666666666666666667, 45.0833333333333333333)	
  
  p1 = c(degmin2decdeg("-595100.00"), 46)
  p2 = c(degmin2decdeg("-574700.00"), 46)
  #p3 = c(-56.40172552969,44.79510535390)
  #pmich = read.csv(file.path(bio.datadirectory, "bio.snowcrab", "maps", "200mile1.csv"))
  #pmich = cbind(as.numeric(as.character(pmich$lon)), as.numeric(as.character(pmich$lat)))
  
  #pmich = pmich[which(pmich[,1] > -56.5 & pmich[,1] < -56 & pmich[,2] > 43 & pmich[,2] < 45),]
  
  #p4 = c(-56.15570315338,44.58068076985)
  p5 = c(degmin2decdeg("-544800.00"), degmin2decdeg("432400.00"))
  p200 = read.csv(file.path(bio.datadirectory, "polygons", "Management_Areas", "Administrative_Boundaries", "limit200.xy"), col.names = c("lon", "lat"), sep = " ")  
  
  #  p200 = read.csv(file.path(bio.datadirectory, "bio.snowcrab", "maps", "200mile1.csv"))
  p200 = cbind(as.numeric(as.character(p200$lon)), as.numeric(as.character(p200$lat)))
  p200 = p200[which(p200[,2] < 43.6),]
  p200 = p200[which(p200[,1] < -54.808),]
  p200 = p200[which(p200[,1] > -57.496),]
  ind = which(p200[,1] > -56.5 & p200[,1] < -56 & p200[,2] > 43)
  p200 = p200[-ind,] 
  p6 = c(-57.5, degmin2decdeg("410500.00"))
  p7 = c(degmin2decdeg("-603100.00"),degmin2decdeg("453700.00"))
  p8 = c(degmin2decdeg("-595100.00"), 46)
  #p2 = c(-58.516666666666666666666667,45.61666666666666666666667)
  # p3 = c(-59.11881785180857,43.67610276909335)
  # p4 = c(-63.33161397633095,42.50186912534272)
  # p5 = c(-63.33296001561555,44.33343763428088)
  #p6 = c(-63.52502801857509,44.5005704612574)
  #p7 = c(-64, 45)
  # p7 = c(-61, 46)
  #  are = rbind(p1, p2, p3, pmich, p4, p5, p200, p6, p7, p8)
  are = rbind(p1, p2, p5, p200, p6, p7, p8)
  
  pa = Polygon(are)
  paa = Polygons(list(pa), "s3")
  twothree = SpatialPolygons(list(paa), 1:1)
  
  SPDF = SpatialPolygonsDataFrame(twothree, data.frame(N = c("cfa_23"), row.names = c("s3")))
  if(polyredo){
    proj4string(SPDF) = CRS(latlong)
    writeOGR(SPDF, layer = 'cfa23', 'C:/temp', driver="ESRI Shapefile")
  }   
  
  #Write cfa24 all so that we can divide later
  if(polyredo){
    
    p11 = c(degmin2decdeg("-612545.00"), degmin2decdeg("453810.00"))
    p10 = c(degmin2decdeg("-612415.00"),    degmin2decdeg("453830.00"))
    p9 = c(degmin2decdeg("-604832.00"), degmin2decdeg("455732.00"))
    p8 = c(degmin2decdeg("-604732.00"), degmin2decdeg("455725.00"))
    p6 = c(degmin2decdeg("-603100.00"), degmin2decdeg("453700.00"))
    p7 = c(degmin2decdeg("-573000.00"), degmin2decdeg("410500.00"))
    p200 = read.csv(file.path(bio.datadirectory, "polygons", "Management_Areas", "Administrative_Boundaries", "limit200.xy"), col.names = c("lon", "lat"), sep = " ")  
    #p200 = read.csv(file.path(bio.datadirectory, "bio.snowcrab", "maps", "200mile1.csv"))
    p200 = cbind(as.numeric(as.character(p200$lon)), as.numeric(as.character(p200$lat)))
    p200 = p200[which(p200[,2] < 45.2),]
    p200 = p200[which(p200[,1] < -57.5),]
    p200 = p200[which(p200[,1] > -70),]
    
    ind = which(p200[,1] > -66.21 & p200[,1] < -59 & p200[,2] > 42)
    p200 = p200[-ind,] 
    
    p11 = c(degmin2decdeg("-612545.00"), degmin2decdeg("453810.00"))
    are = rbind(p11, p10, p9, p8, p6, p7, p200, p11)
    
    pa = Polygon(are)
    paa = Polygons(list(pa), "s3")
    twofourall = SpatialPolygons(list(paa), 1:1)
    
    SPDF = SpatialPolygonsDataFrame(twofourall, data.frame(N = c("cfa_24_all"), row.names = c("s3")))
    
    proj4string(SPDF) = CRS(latlong)
    writeOGR(SPDF, layer = 'cfa24_all', 'C:/temp', driver="ESRI Shapefile")
    
    
    #    1.            44° 30' 00"N      63° 31' 12" W
    #     2.            44° 20' 00"N      63° 20' 00" W
    #    3.            39° 00' 00"N      63° 20' 00" W
    
    p1 = c(degmin2decdeg("-633112.00"), degmin2decdeg("443000.00"))
    p2 = c(degmin2decdeg("-632000.00"),    degmin2decdeg("442000.00"))
    p3 = c(degmin2decdeg("-632000.00"), degmin2decdeg("390000.00"))
    p4 = c(-70, 38)
    p5 = c(-75, 50)
    
    are = rbind(p1, p2, p3, p4, p5, p1)
    
    pa = Polygon(are)
    paa = Polygons(list(pa), "s4")
    twofourw = SpatialPolygons(list(paa), 1:1)
    
    SPDF = SpatialPolygonsDataFrame(twofourw, data.frame(N = c("cfa_24_w"), row.names = c("s4")))
    
    proj4string(SPDF) = CRS(latlong)
    writeOGR(SPDF, layer = 'cfa24_W', 'C:/temp', driver="ESRI Shapefile")
    
  }
  
  # #From licence conditions CFA23
  # #NAD27
  # nadlatlong = "+proj=longlat +datum=NAD27 +no_defs"
  # p1 = c(-59.849166666666666666666667,46)
  # p2 = c(-57.7991666666666666666667,46)
  # p3 = c(-54.7991666666666666666667,43.4)
  # #THENCE ALONG THE BOUNDARY OF THE CANADIAN 200 MILE LIMIT TO
  # p4 = c(-57.498888888888888888883333333,41.083611111111111111166666667)		
  # p5 = c(-60.5158333333333333333333333,45.616666666666666667)	
  # p6 = c(-59.849166666666666666666667,46)		
  # 
  # 
  #               are = rbind(p1, p2, p3, p4, p5, p6)
  #               pa = Polygon(are)
  #               paa = Polygons(list(pa), "s9")
  #               twothree = SpatialPolygons(list(paa), 1:1)
  #               
  #               SPDF = SpatialPolygonsDataFrame(twothree, data.frame(N = c("cfa_23_lic"), row.names = c("s9")))
  #               proj4string(SPDF) = CRS(nadlatlong)
  #               writeOGR(SPDF, layer = 'cfa23_lic', 'C:/temp', driver="ESRI Shapefile")
  #               
  #               
  # CFA 24 - EAST IS DEFINED AS THOSE PORTIONS OF CANADIAN FISHERIES WATERS BOUNDED BY RHUMB LINES (SIMILAR TO STRAIGHT LINES PLOTTED ON A NAUTICAL CHART), THE BOUNDARY OF THE CANADIAN 200 MILE LIMIT, AND THE COASTLINE OF NOVA SCOTIA JOINING THE FOLLOWING POINTS IN THE ORDER IN WHICH THEY ARE LISTED BELOW:
  #   
  #   POINT    NORTH LATITUDE   WEST LONGITUDE
  # 
  # 1)	      45?37'			     60?31'
  # 2)	      41?05'			     57?30'	THENCE ALONG THE BOUNDARY OF THE CANADIAN 200 MILE LIMIT TO
  # 3)	      40?30' 			     63?20' 
  # 4)	      44?20'			     63?20'
  # 5)	      44?30'			     63?30'
  # 6)	      44?30'			     63?31.5'
  # 7)	      45?37'			     60?31'
  p1 = c(-60.51666666666666666666666666666667, 45.61666666666666666666666666666667)
  p2 = c(-57.5,    41.08333333333333333333333333333333)
  p200 = read.csv(file.path(bio.datadirectory, "polygons", "Management_Areas", "Administrative_Boundaries", "limit200.xy"), col.names = c("lon", "lat"), sep = " ")  
  #p200 = read.csv(file.path(bio.datadirectory, "bio.snowcrab", "maps", "200mile1.csv"))
  p200 = cbind(as.numeric(as.character(p200$lon)), as.numeric(as.character(p200$lat)))
  p200 = p200[which(p200[,2] < 41.2),]
  p200 = p200[which(p200[,1] < -57.5),]
  p200 = p200[which(p200[,1] > -63.3333333333333333333),]
  
  p3 = c(-63.33333333333333333333333333333333, 40.5)
  p4 = c(-63.33333333333333333333333333333333, 44.33333333333333333333333333333333)
  p5 = c(-63.5, 44.5)
  p6 = c(-63.525, 44.5)
  p7 = c(-64,45)
  p8 = c(-61, 45.8)
  p9 = c(-60.51666666666666666666666666666667, 45.61666666666666666666666666666667)
  
  # 
  # p1 = c(-57.78560987011954,46.00106076110973) 
  # p2 = c(-59.85247480316924,46.00291960992756) 
  # p3 = c(-61, 46)
  # p4 = c(-60.66040620990439,45.58083805201212)
  # p5 = c(-59.11881785180857,43.67610276909335)
  # p6 = c(-56.5, 44)
  # p7 = c(-57.78560987011954,46.00106076110973) 
  are = rbind(p1, p2, p200, p3, p4, p5, p6, p7, p8, p9)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s4")
  twofour = SpatialPolygons(list(paa), 1:1)
  
  
  SPDF = SpatialPolygonsDataFrame(twofour, data.frame(N = c("cfa_24"), row.names = c("s4")))
  # proj4string(SPDF) = CRS(latlong)
  # writeOGR(SPDF, layer = 'cfa24', 'C:/temp', driver="ESRI Shapefile")
  
  
  
  # 1. FISHING IS AUTHORIZED IN THE CRAB FISHING AREA THAT IS VALIDATED BELOW DURING THE TIME SPECIFIED IN THE LICENCE CONDITION OR UNTIL THE QUOTA IS REACHED, WHICHEVER COMES FIRST:
  #   
  #   THAT PORTION OF CRAB FISHING AREA 24 DESCRIBED AS WEST OF A STRAIGHT LINE JOINING THE FOLLOWING POINTS IN THE ORDER IN WHICH THEY APPEAR.
  # 
  # POINT	LATITUDE	LONGITUDE
  # 
  # 1.	44  30' 00""N	63  31' 12"" W
  # 2.	44  20' 00""N	63  20' 00"" W
  # 3.	39  00' 00""N	63  20' 00"" W
  
  p1 = c(-63.52, 44.5)
  p2 = c(-63.33333333333333333333333333333333,44.33333333333333333333333333333333)
  #p3 = c(-63.33333333333333333333333333333333,39)
  p3 = c(-63.33333333333333333333333333333333, 40.5)
  
  p200 = read.csv(file.path(bio.datadirectory, "polygons", "Management_Areas", "Administrative_Boundaries", "limit200.xy"), col.names = c("lon", "lat"), sep = " ")  
  #p200 = read.csv(file.path(bio.datadirectory, "bio.snowcrab", "maps", "200mile1.csv"))
  p200 = cbind(as.numeric(as.character(p200$lon)), as.numeric(as.character(p200$lat)))
  p200 = p200[which(p200[,2] < 45.6),]
  p200 = p200[which(p200[,1] <  -63.3333333333333333333),]
  p200 = p200[which(p200[,1] > -68),]
  ind = which(p200[,1] > -66.213641822 & p200[,2] > 43.25)
  p200 = p200[-ind,] 
  
  pr = c(-64, 45)
  pe = c(-63.52, 44.5)
  #   p1 = c(-63.33333333333333333333333333333333,44.33333333333333333333333333333333)
  #   p2 =c(-63.33333333333333333333333333333333, 40.5)
  #   p3 = c(-65.8790362550903,40.0530157742342)
  #   p4 = c(-65.6997185793320,40.4513853244497)
  #   p5 = c(-67.74305555556,42.88722222201)
  # p6 = c(-67.4055058928356,43.8333320617655)
  # p7 = c(-66.9031298,43.8333306)
  #        p8 = c(-66.903129569,45.058746266)
  # 
  #   p9 = c(-65, 45.5)
  #   p10 = c(-63.33333333333333333333333333333333,44.33333333333333333333333333333333)
  #   
  #   are = rbind(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)
  are = rbind(p1, p2, p3, p200, pr, pe)
  
  pa = Polygon(are)
  paa = Polygons(list(pa), "s5")
  xxxx = SpatialPolygons(list(paa), 1:1)
  
  SPDF = SpatialPolygonsDataFrame(xxxx, data.frame(N = c("cfa_4x"), row.names = c("s5")))
  # proj4string(SPDF) = CRS(latlong)
  # writeOGR(SPDF, layer = 'cfa4x', 'C:/temp', driver="ESRI Shapefile")
  # 
  p1 = c(-61.4,44)
  p2 = c(-61.4,45.5)
  p3 = c(-58,45.5)
  p4 = c(-58,44)
  p5 = c(-61.4,44)
  are = rbind(p1, p2, p3, p4, p5)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  holes = SpatialPolygons(list(paa), 1:1)
  
  
  p1 = c(-62.5,43.8)
  p2 = c(-62.5,45.7)
  p3 = c(-59.2,45.7)
  p4 = c(-59.2,43.8)
  p5 = c(-62.5,43.8)
  are = rbind(p1, p2, p3, p4, p5)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  twofourz = SpatialPolygons(list(paa), 1:1)
  
  
  
  p1 = c(-60.6,44.1)
  p2 = c(-60.6,46.1)
  p3 = c(-57.75,46.1)
  p4 = c(-57.75,44.1)
  p5 == c(-60.6,44.1)
  are = rbind(p1, p2, p3, p4, p5)
  pa = Polygon(are)
  paa = Polygons(list(pa), "s1")
  twothreez = SpatialPolygons(list(paa), 1:1)
  
  
  
  
  bol = NULL
  for(i in 1:length(abslon)){
    pb = SpatialPoints(rbind(c(as.numeric(abslon[i]), as.numeric(abslat[i]))))
    
    
    
    # all.holes,44,45.5,61.4,58
    bo = FALSE
    if(area == "cfa23"){
      if(gContains(twothree, pb)) bo = TRUE
    }
    
    if(area == "cfa23zoom"){
      if(gContains(twothreez, pb)) bo = TRUE
    }
    if(area == "cfa24"){
      if(gContains(twofour, pb)) bo = TRUE
    }
    if(area == "cfa24zoom"){
      if(gContains(twofourz, pb)) bo = TRUE
    }
    if(area == "cfa4x" | area == "unknown"){
      if(gContains(xxxx, pb)){
        bo = TRUE
        are[i] = "CFA-4X"
        
      }
    }
    if(area == "nens" | area == "unknown"){
      
      if(gContains(nens, pb)){
        bo = TRUE
        are[i] = "NENS"
      }
    }  
    if(area == "nens_gulf"){
      if(gContains(nens, pb) | gContains(gulf, pb)) bo = TRUE
    }  
    
    
    if(area == "sens" | area == "unknown"){
      
      if(gContains(twofour, pb) | gContains(twothree, pb)){
        are[i] = "SENS"
        bo = TRUE
      }
    } 
    if(area == "gulf" | area == "unknown"){
      
      if(gContains(gulf, pb)){
        bo = TRUE
        are[i] = "GULF" 
      }
    } 
    if(area == "all" | area == "ens"){
      if(gContains(twofour, pb) | gContains(twothree, pb) | gContains(xxxx, pb) | gContains(nens, pb)) bo = TRUE
    }
    if(area == "allandgulf"){
      if(gContains(twofour, pb) | gContains(twothree, pb) | gContains(xxxx, pb) | gContains(nens, pb) | gContains(gulf, pb)) bo = TRUE
    }
    if(area == "all.holes"){
      if(gContains(holes, pb)) bo = TRUE
    }  
    bol = c(bol, bo)
    
    
    
  }
  
  if(area == "unknown"){
    return(are)
  }
  return(bol)
  
}


